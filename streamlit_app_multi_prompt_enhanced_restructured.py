#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
streamlit_app_multi_prompt_enhanced_restructured.py

üöÄ STREAMLIT-APP - Umstrukturiert ohne Sidebar
üìä Version: 9.0 - Main Page Layout
üéØ Features: Multi-Prompt-System + Layout-Integration + CI-Palette

STRUKTUR:
1. Layouteingabe (Skizzen + Farbpalette)
2. Text-Inhalte (mit Logo)
3. Motiv & Style
4. Generation (nur Multi-Prompt System)
"""

import os
import sys
import yaml
import json
from datetime import datetime
import time
import streamlit as st
from pathlib import Path
import logging
from PIL import Image
import PyPDF2
import io
import random

# Robuste Python-Pfad-Konfiguration f√ºr Streamlit
current_file = Path(__file__).resolve()
project_root = current_file.parent.resolve()  # Aktuelles Verzeichnis als Root

# Alle m√∂glichen Pfade hinzuf√ºgen
paths_to_add = [
    str(project_root),                          # Root-Verzeichnis (CreativeAI_launch)
    str(project_root / "src"),                  # src-Verzeichnis
    str(project_root / "utils"),                # utils-Verzeichnis
]

# Bereinige und f√ºge Pfade hinzu
for path in paths_to_add:
    if path in sys.path:
        sys.path.remove(path)
    sys.path.insert(0, path)

# Debug-Info nur im Entwicklungsmodus
if os.getenv('DEBUG_IMPORTS'):
    print(f"DEBUG: project_root = {project_root}")
    print(f"DEBUG: src exists = {(project_root / 'src').exists()}")
    print(f"DEBUG: workflow exists = {(project_root / 'src' / 'workflow').exists()}")
    print(f"DEBUG: sys.path first 3 = {sys.path[:3]}")

# =====================================
# MIDJOURNEY MOTIV GENERATOR IMPORT
# =====================================

# Midjourney Motiv Generator Import
try:
    from src.prompt.midjourney_motiv_generator import MidjourneyMotivGenerator
    MIDJOURNEY_MOTIV_GENERATOR_AVAILABLE = True
    print("‚úÖ Midjourney Motiv Generator erfolgreich importiert")
    
    # Globale Instanz erstellen
    midjourney_generator = MidjourneyMotivGenerator()
    
    def generate_midjourney_motiv_prompt(**kwargs):
        return midjourney_generator.generate_motiv_prompt(**kwargs)
        
except ImportError as e:
    MIDJOURNEY_MOTIV_GENERATOR_AVAILABLE = False
    print(f"‚ö†Ô∏è Midjourney Motiv Generator nicht verf√ºgbar: {e}")
    # Fallback-Funktion definieren
    def generate_midjourney_motiv_prompt(**kwargs):
        return "Midjourney Motiv Generator nicht verf√ºgbar - bitte installieren Sie die Abh√§ngigkeiten"

# =====================================
# TEXT TO MOTIV CONVERTER IMPORT
# =====================================
try:
    from src.prompt.gpt_motiv_generator import TextToMotivConverter, create_text_to_motiv_converter
    TEXT_TO_MOTIV_CONVERTER_AVAILABLE = True
    print("‚úÖ Text zu Motiv Converter erfolgreich importiert")
    
    # Globale Instanz erstellen
    text_to_motiv_converter = create_text_to_motiv_converter()
    
    def generate_motiv_from_textelements(**kwargs):
        return text_to_motiv_converter.generate_motiv_from_textelements(**kwargs)
        
except ImportError as e:
    TEXT_TO_MOTIV_CONVERTER_AVAILABLE = False
    print(f"‚ö†Ô∏è Text zu Motiv Converter nicht verf√ºgbar: {e}")
    # Fallback-Funktion definieren
    def generate_motiv_from_textelements(**kwargs):
        return "Text zu Motiv Converter nicht verf√ºgbar - bitte installieren Sie die Abh√§ngigkeiten"

# =====================================
# KI CREATIVE TEXT GENERATOR IMPORT
# =====================================
try:
    from src.prompt.ki_creative_text_generator import KICreativeTextGenerator, create_ki_creative_text_generator
    KI_CREATIVE_TEXT_GENERATOR_AVAILABLE = True
    print("‚úÖ KI Creative Text Generator erfolgreich importiert")
    
    # Globale Instanz erstellen
    ki_creative_generator = create_ki_creative_text_generator()
    
    def generate_creative_texts(**kwargs):
        return ki_creative_generator.generate_creative_texts(**kwargs)
        
except ImportError as e:
    KI_CREATIVE_TEXT_GENERATOR_AVAILABLE = False
    print(f"‚ö†Ô∏è KI Creative Text Generator nicht verf√ºgbar: {e}")
    # Fallback-Funktion definieren
    def generate_creative_texts(**kwargs):
        return None

# =====================================
# DYNAMIC SCENE SELECTOR IMPORT
# =====================================
DYNAMIC_SCENE_SELECTOR_AVAILABLE = False
scene_selector = None

try:
    from src.prompt.dynamic_scene_selector import DynamicSceneSelector
    DYNAMIC_SCENE_SELECTOR_AVAILABLE = True
    print("‚úÖ Dynamic Scene Selector erfolgreich importiert")
    
    # Globale Instanz erstellen
    scene_selector = DynamicSceneSelector()
    print(f"‚úÖ Scene Selector Instanz erstellt: {scene_selector}")
    
except ImportError as e:
    DYNAMIC_SCENE_SELECTOR_AVAILABLE = False
    print(f"‚ö†Ô∏è Dynamic Scene Selector nicht verf√ºgbar: {e}")
    scene_selector = None
except Exception as e:
    DYNAMIC_SCENE_SELECTOR_AVAILABLE = False
    print(f"‚ùå Fehler beim Erstellen der Scene Selector Instanz: {e}")
    scene_selector = None

# =====================================
# GPT-5 BILDGENERATOR IMPORT
# =====================================
try:
    from src.image.gpt5_image_generator import generate_gpt5_image
    GPT5_IMAGE_GENERATOR_AVAILABLE = True
    print("‚úÖ GPT-5 Bildgenerator erfolgreich importiert")
except ImportError as e:
    GPT5_IMAGE_GENERATOR_AVAILABLE = False
    print(f"‚ö†Ô∏è GPT-5 Bildgenerator nicht verf√ºgbar: {e}")
    # Fallback-Funktion definieren
    def generate_gpt5_image(**kwargs):
        return None, {"error": "GPT-5 Bildgenerator nicht verf√ºgbar"}

# =====================================
# FUNCTIONS DEFINITIONS
# =====================================

def _get_job_interpretation(job_title: str) -> str:
    """Gibt eine benutzerfreundliche Interpretation des Stellentitels zur√ºck"""
    
    if not job_title or not job_title.strip():
        return None
    
    job_title_lower = job_title.lower().strip()
    
    # Pflege-Bereich
    if any(word in job_title_lower for word in ["pflege", "nurse", "krankenschwester", "krankenpfleger"]):
        if "intensiv" in job_title_lower or "icu" in job_title_lower:
            return "Intensivpflege-Kraft (Intensive Care Nurse)"
        elif "ambulant" in job_title_lower or "ambulatory" in job_title_lower:
            return "Ambulante Pflegekraft (Ambulatory Care Nurse)"
        elif "station√§r" in job_title_lower or "stationary" in job_title_lower:
            return "Station√§re Pflegekraft (Ward Nurse)"
        else:
            return "Pflegekraft (Registered Nurse)"
    
    # √Ñrzte-Bereich
    elif any(word in job_title_lower for word in ["arzt", "doctor", "mediziner", "physician"]):
        if "chirurg" in job_title_lower or "surgeon" in job_title_lower:
            return "Chirurg/Chirurgin (Surgeon)"
        elif "internist" in job_title_lower:
            return "Internist/Internistin (Internist)"
        elif "an√§sthesist" in job_title_lower or "anesthesiologist" in job_title_lower:
            return "An√§sthesist/An√§sthesistin (Anesthesiologist)"
        else:
            return "Arzt/√Ñrztin (Physician)"
    
    # Therapeuten-Bereich
    elif any(word in job_title_lower for word in ["therapeut", "therapist", "physio", "ergo"]):
        if "physio" in job_title_lower:
            return "Physiotherapeut/in (Physical Therapist)"
        elif "ergo" in job_title_lower or "occupational" in job_title_lower:
            return "Ergotherapeut/in (Occupational Therapist)"
        elif "psycho" in job_title_lower:
            return "Psychotherapeut/in (Psychotherapist)"
        else:
            return "Therapeut/in (Therapist)"
    
    # Verwaltung/Management
    elif any(word in job_title_lower for word in ["verwaltung", "administration", "management", "leitung", "leitungskraft"]):
        return "Verwaltungs-/F√ºhrungskraft (Healthcare Administrator)"
    
    # Technische Berufe
    elif any(word in job_title_lower for word in ["techniker", "technician", "labor", "radiologie", "radiology"]):
        if "labor" in job_title_lower:
            return "Laborant/in (Laboratory Technician)"
        elif "radiologie" in job_title_lower or "radiology" in job_title_lower:
            return "Radiologietechniker/in (Radiology Technician)"
        else:
            return "Medizintechniker/in (Medical Technician)"
    
    # Sozialarbeiter
    elif any(word in job_title_lower for word in ["sozial", "social", "berater", "counselor"]):
        return "Sozialarbeiter/in (Social Worker)"
    
    # Fallback f√ºr unbekannte Berufe
    else:
        if "kraft" in job_title_lower or "assistent" in job_title_lower:
            return "Fachkraft/Assistent/in (Healthcare Professional)"
        elif "fach" in job_title_lower:
            return "Fachkraft (Healthcare Specialist)"
        else:
            return "Gesundheitsfachkraft (Healthcare Professional)"

def _adjust_color_opacity(hex_color: str, opacity: float) -> str:
    """Simuliert Transparenz durch Verdunkelung/Aufhellung"""
    try:
        hex_color = hex_color.lstrip('#')
        r, g, b = int(hex_color[0:2], 16), int(hex_color[2:4], 16), int(hex_color[4:6], 16)
        # Mische mit Wei√ü f√ºr Transparenz-Effekt
        r = int(r + (255 - r) * (1 - opacity))
        g = int(g + (255 - g) * (1 - opacity))
        b = int(b + (255 - b) * (1 - opacity))
        return f"#{r:02x}{g:02x}{b:02x}"
    except:
        return '#E0E0E0'  # Fallback

def optimize_german_text_for_dalle(text: str, max_length: int = 35) -> str:
    """
    Optimiert deutschen Text f√ºr DALL-E 3:
    - Verhindert abgeschnittene W√∂rter
    - Ersetzt Umlaute durch ASCII-√Ñquivalente
    - K√ºrzt intelligent ohne Wortbruch
    """
    # Umlaute ersetzen (DALL-E 3 Problem)
    umlaut_map = {
        '√§': 'ae', '√∂': 'oe', '√º': 'ue', '√ü': 'ss',
        '√Ñ': 'Ae', '√ñ': 'Oe', '√ú': 'Ue'
    }
    
    for umlaut, replacement in umlaut_map.items():
        text = text.replace(umlaut, replacement)
    
    # Wenn Text zu lang ist, k√ºrze intelligent
    if len(text) > max_length:
        # Versuche bei Leerzeichen zu k√ºrzen
        words = text.split()
        shortened = ""
        
        for word in words:
            if len(shortened + " " + word) <= max_length:
                shortened += (" " + word) if shortened else word
            else:
                # Wort ist zu lang - k√ºrze es
                if len(word) > max_length:
                    # K√ºrze auf max_length - 3 (f√ºr "...")
                    shortened += (" " + word[:max_length-3] + "...") if shortened else (word[:max_length-3] + "...")
                break
        
        return shortened.strip()
    
    return text

def create_dalle_safe_text_instructions() -> str:
    """
    Erstellt sichere Text-Anweisungen f√ºr DALL-E 3
    """
    return """
‚Äî TEXT-RENDERING REGELN (***KRITISCH F√úR DEUTSCHE TEXTE***)
‚Ä¢ KEINE Umlaute (√§,√∂,√º,√ü) verwenden - ersetze durch ae,oe,ue,ss
‚Ä¢ KEINE abgeschnittenen W√∂rter - k√ºrze bei Wortgrenzen
‚Ä¢ KEINE zu langen Texte - max 35 Zeichen pro Element
‚Ä¢ KEINE komplexe Zeichensetzung - einfache S√§tze bevorzugen
‚Ä¢ VERWENDE nur ASCII-Zeichen f√ºr maximale Kompatibilit√§t

‚Äî TEXT-OPTIMIERUNG:
‚Ä¢ "Werden Sie Teil unseres Teams!" ‚Üí "Werden Sie Teil unseres Teams!"
‚Ä¢ "Flexible Arbeitszeiten" ‚Üí "Flexible Arbeitszeiten"
‚Ä¢ "Attraktive Verg√ºtung" ‚Üí "Attraktive Verguetung"
‚Ä¢ "Fortbildungsm√∂glichkeiten" ‚Üí "Fortbildungsmoeglichkeiten"
‚Ä¢ "Jetzt bewerben!" ‚Üí "Jetzt bewerben!"
"""

def load_ci_colors_enhanced():
    """Lade CI-Farben aus YAML und erweitere um berechnete Farben"""
    
    ci_colors_path = project_root / "input_config" / "ci_colors.yaml"
    
    try:
        with open(ci_colors_path, 'r', encoding='utf-8') as f:
            colors_data = yaml.safe_load(f)
        
        # Erweiterte Paletten mit Akzent-Beschreibungen
        enhanced_palettes = {}
        
        for palette in colors_data.get('palettes', []):
            name = palette.get('name', 'Unbenannt')
            enhanced_palettes[name] = {
                "primary": palette.get('primary', '#005EA5'),
                "secondary": palette.get('secondary', '#B4D9F7'),
                "accent": palette.get('accent', '#FFC20E'),
                # Neue berechnete Farben
                "headline_color": palette.get('primary', '#005EA5'),
                "cta_background": palette.get('accent', '#FFC20E'),
                "bullet_color": palette.get('accent', '#FFC20E'),
                "description": f"Primary: {palette.get('primary')}, Accent: {palette.get('accent')}"
            }
        
        return enhanced_palettes
         
    except Exception as e:
        st.error(f"Fehler beim Laden der CI-Farben: {e}")
        return {}

def generate_random_ci_palette():
    """Generiert eine zuf√§llige CI-Farbpalette f√ºr das Layout"""
    
    # Professionelle CI-Farben-Palette f√ºr Gesundheitswesen
    ci_color_palettes = [
        {
            "name": "Medizinisches Blau-Gold",
            "primary": "#005EA5",      # Dunkelblau
            "secondary": "#B4D9F7",    # Hellblau
            "accent": "#FFC20E",       # Gold
            "description": "Klassische medizinische Farben"
        },
        {
            "name": "Naturverbunden Gr√ºn-Koralle",
            "primary": "#2E7D32",      # Dunkelgr√ºn
            "secondary": "#C8E6C9",    # Hellgr√ºn
            "accent": "#FF7043",       # Koralle
            "description": "Naturverbundene, beruhigende Farben"
        },
        {
            "name": "Professionell Navy-Silber",
            "primary": "#1A237E",      # Navy
            "secondary": "#E8EAF6",    # Silber
            "accent": "#FF9800",       # Orange
            "description": "Professionelle Business-Farben"
        },
        {
            "name": "Vertrauensvoll Teal-Orange",
            "primary": "#00695C",      # Teal
            "secondary": "#B2DFDB",    # Hellteal
            "accent": "#FF5722",       # Orange
            "description": "Moderne, vertrauensvolle Farben"
        },
        {
            "name": "Elegant Burgund-Creme",
            "primary": "#8E24AA",      # Burgund
            "secondary": "#F3E5F5",    # Creme
            "accent": "#FFC107",       # Gelb
            "description": "Elegante, traditionelle Farben"
        },
        {
            "name": "Zeitlos Grau-Blau",
            "primary": "#424242",      # Grau
            "secondary": "#E3F2FD",    # Hellblau
            "accent": "#2196F3",       # Blau
            "description": "Zeitlose, seri√∂se Farben"
        },
        {
            "name": "Beruhigend Smaragd-Lavendel",
            "primary": "#388E3C",      # Smaragd
            "secondary": "#E1F5FE",    # Hellblau
            "accent": "#9C27B0",       # Lavendel
            "description": "Beruhigende, heilende Farben"
        },
        {
            "name": "Dynamisch Schwarz-Rot",
            "primary": "#212121",      # Schwarz
            "secondary": "#FFEBEE",    # Hellrot
            "accent": "#F44336",       # Rot
            "description": "Kontrastreiche, dynamische Farben"
        },
        {
            "name": "Warm Beige-Terrakotta",
            "primary": "#8D6E63",      # Beige
            "secondary": "#EFEBE9",    # Hellbeige
            "accent": "#D84315",       # Terrakotta
            "description": "Warme, einladende Farben"
        },
        {
            "name": "Frisch Mint-Pfirsich",
            "primary": "#4DB6AC",      # Mint
            "secondary": "#E0F2F1",    # Hellmint
            "accent": "#FFAB91",       # Pfirsich
            "description": "Frische, moderne Farben"
        }
    ]
    
    # Zuf√§llige Farbpalette ausw√§hlen
    selected_palette = random.choice(ci_color_palettes)
    
    return {
        "name": f"üé≤ {selected_palette['name']}",
        "primary": selected_palette["primary"],
        "secondary": selected_palette["secondary"],
        "accent": selected_palette["accent"],
        "headline_color": selected_palette["primary"],
        "cta_background": selected_palette["accent"],
        "bullet_color": selected_palette["accent"],
        "description": selected_palette["description"]
    }

def load_original_sketches():
    """Lade Originalskizzen f√ºr Layout-Vorschau"""
    sketches = {}
    sketch_files = {
        "Skizze1": "Skizzen/Skizze1.png",
        "Skizze2": "Skizzen/Skizze2.png", 
        "Skizze3": "Skizzen/Skizze3.png",
        "Skizze4": "Skizzen/Skizze4.png",
        "Skizze5": "Skizzen/Skizze5.png",
        "Skizze6": "Skizzen/Skizze6.png",
        "Skizze7": "Skizzen/Skizze7.png",
        "Skizze8": "Skizzen/Skizze8.png",
        "Skizze9": "Skizzen/Skizze9.png",
        "Skizze10": "Skizzen/Skizze10.png",
        "Skizze11": "Skizzen/Skizze11.png",
        "Skizze12": "Skizzen/Skizze12.png",
        "Skizze13": "Skizzen/Skizze13.png"
    }
    
    for name, path in sketch_files.items():
        if os.path.exists(path):
            sketches[name] = {
                "name": name,
                "path": path
            }
    
    return sketches

def display_sketch_preview(sketch_data, layout_id, selected_layout_id):
    """Zeige Sketch-Vorschau korrekt an"""
    if sketch_data and sketch_data.get("path"):
        try:
            from PIL import Image
            sketch_image = Image.open(sketch_data["path"])
            
            # Optimale Gr√∂√üe: Nicht zu klein, aber kompakt mit guter Qualit√§t
            sketch_image.thumbnail((120, 120), Image.Resampling.LANCZOS)
            
            # Border f√ºr ausgew√§hltes Layout
            border_color = "#1f77b4" if layout_id == selected_layout_id else "#ddd"
            border_width = "3px" if layout_id == selected_layout_id else "2px"
            
            st.markdown(f"""
            <div style="border: {border_width} solid {border_color}; border-radius: 8px; padding: 8px; background: white; width: fit-content; margin: 0 auto;">
            """, unsafe_allow_html=True)
            
            # Sketch anzeigen
            st.image(sketch_image, 
                    caption=f"{sketch_data['name']}", 
                    width=120)
            
            st.markdown("</div>", unsafe_allow_html=True)
            
        except Exception as e:
            st.error(f"Fehler beim Laden der Skizze: {e}")
            st.info(f"Skizze nicht verf√ºgbar")
    else:
        st.info(f"Skizze nicht verf√ºgbar")

# Robuste Import-Strategie f√ºr Streamlit
MULTI_PROMPT_AVAILABLE = False
ENHANCED_CREATIVE_AVAILABLE = False
LANGGRAPH_AVAILABLE = False

# Definiere alle m√∂glichen Import-Strategien
import_strategies = [
    # Strategie 1: Standard src-Imports (mit korrigiertem Pfad)
    lambda: (
        __import__('src.workflow.multi_prompt_system', fromlist=['MultiPromptSystem', 'create_multi_prompt_system', 'StructuredInput']),
        __import__('src.image.enhanced_creative_generator', fromlist=['create_enhanced_creative_generator', 'generate_creative_from_multiprompt_result']),
        __import__('src.workflow.langgraph_integration', fromlist=['run_enhanced_workflow_from_streamlit', 'create_langgraph_integration'])
    ),
    # Strategie 2: Direkte Imports (falls src im sys.path)
    lambda: (
        __import__('workflow.multi_prompt_system', fromlist=['MultiPromptSystem', 'create_multi_prompt_system', 'StructuredInput']),
        __import__('image.enhanced_creative_generator', fromlist=['create_enhanced_creative_generator', 'generate_creative_from_multiprompt_result']),
        __import__('workflow.langgraph_integration', fromlist=['run_enhanced_workflow_from_streamlit', 'create_langgraph_integration'])
    ),
    # Strategie 3: Einfache Imports (f√ºr den Fall, dass die anderen fehlschlagen)
    lambda: (
        __import__('src.workflow.multi_prompt_system'),
        __import__('src.image.enhanced_creative_generator'),
        __import__('src.workflow.langgraph_integration')
    )
]

# Versuche Import-Strategien nacheinander
for i, strategy in enumerate(import_strategies, 1):
    try:
        if os.getenv('DEBUG_IMPORTS'):
            st.write(f"üîÑ Versuche Import-Strategie {i}...")
        
        # Import versuchen
        workflow_module, image_module, langgraph_module = strategy()
        
        # Module-Attribute extrahieren
        MultiPromptSystem = getattr(workflow_module, 'MultiPromptSystem')
        create_multi_prompt_system = getattr(workflow_module, 'create_multi_prompt_system')
        StructuredInput = getattr(workflow_module, 'StructuredInput')
        
        create_enhanced_creative_generator = getattr(image_module, 'create_enhanced_creative_generator')
        generate_creative_from_multiprompt_result = getattr(image_module, 'generate_creative_from_multiprompt_result')
        
        run_enhanced_workflow_from_streamlit = getattr(langgraph_module, 'run_enhanced_workflow_from_streamlit')
        create_langgraph_integration = getattr(langgraph_module, 'create_langgraph_integration')
        
        # Verify StructuredInput has cta attribute
        if hasattr(StructuredInput, '__dataclass_fields__') and 'cta' in StructuredInput.__dataclass_fields__:
            cta_status = "‚úÖ CTA-Attribut verf√ºgbar"
        else:
            cta_status = "‚ö†Ô∏è CTA-Attribut fehlt"
        
        MULTI_PROMPT_AVAILABLE = True
        ENHANCED_CREATIVE_AVAILABLE = True
        LANGGRAPH_AVAILABLE = True
        
        # Status-Meldungen entfernt - nur noch in Logs
        pass
        break
        
    except Exception as e:
        if os.getenv('DEBUG_IMPORTS'):
            st.warning(f"‚ö†Ô∏è Import-Strategie {i} fehlgeschlagen: {str(e)}")
        continue

# Fallback, wenn alle Strategien fehlschlagen
if not MULTI_PROMPT_AVAILABLE:
    st.error("‚ùå **Import-Fehler**: Multi-Prompt-System konnte nicht geladen werden")
    st.write("**Debug-Informationen:**")
    st.write(f"- **Project Root**: `{project_root}`")
    st.write(f"- **Src Verzeichnis existiert**: {(project_root / 'src').exists()}")
    st.write(f"- **Workflow Verzeichnis existiert**: {(project_root / 'src' / 'workflow').exists()}")
    st.write(f"- **Python Path (erste 3)**:")
    for i, path in enumerate(sys.path[:3], 1):
        st.write(f"  {i}. `{path}`")
    
    st.info("üí° **Hilfe**: Stelle sicher, dass du das Streamlit-App aus dem Projekt-Root-Verzeichnis startest")
    st.stop()

# Page Config
st.set_page_config(
    page_title="üöÄ CreativeAI - Promptgenerator",
    page_icon="üé®",
    layout="wide"
)

# Custom CSS
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(90deg, #1e40af 0%, #3b82f6 100%);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        text-align: center;
        margin-bottom: 2rem;
    }
    .color-preview {
        width: 50px;
        height: 20px;
        border-radius: 5px;
        display: inline-block;
        margin: 5px;
        border: 1px solid #ddd;
    }
    .layout-preview {
        background: #f8f9fa;
        padding: 1rem;
        border-radius: 8px;
        border: 1px solid #e9ecef;
        margin: 0.5rem 0;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.markdown("""
<div class="main-header">
    <h1>üöÄ CreativeAI - Promptgenerator</h1>
    <p>Intelligente Prompt-Generierung f√ºr DALL-E & Midjourney</p>
</div>
""", unsafe_allow_html=True)

# =====================================
# 1. LAYOUTEINGABE (Skizzen + Farbpalette)
# =====================================

st.header("üé® Layouteingabe")

# Layout-Eingabe-Modus Auswahl
st.subheader("üìê Layout-Eingabe-Modus")

layout_input_mode = st.radio(
    "W√§hle deinen Layout-Eingabe-Modus:",
    ["üé≤ Automatische Eingabe", "üéØ Manuelle Eingabe"],
    help="Automatisch: Zuf√§lliges Layout wird gew√§hlt | Manuell: W√§hle ein spezifisches Layout",
    index=0  # Standardm√§√üig Automatische Eingabe
)

# Layout-Style Auswahl (NEU)
st.subheader("üé® Layout-Style")

layout_style = st.selectbox(
    "Layout-Konturen:",
    options=[
        ("sharp_geometric", "üé® Scharf & Geometrisch"),
        ("rounded_modern", "üîµ Abgerundet & Modern"),
        ("organic_flowing", "üåä Organisch & Flie√üend"),
        ("wave_contours", "üåä Wellige Konturen"),
        ("hexagonal", "‚¨° Sechseckig"),
        ("circular", "‚≠ï Kreisf√∂rmig"),
        ("asymmetric", "‚ö° Asymmetrisch"),
        ("minimal_clean", "‚ö™ Minimal & Clean")
    ],
    format_func=lambda x: x[1],
    index=1,  # Default: rounded_modern
    help="Bestimmt die Kontur-Form der Layout-Bereiche im generierten Bild",
    key="layout_style_input"
)
# Wert in Session State speichern
st.session_state['layout_style'] = layout_style

# Layout-Style Beschreibung
layout_style_descriptions = {
    "sharp_geometric": "Scharfe, eckige Konturen f√ºr ein modernes, technisches Aussehen",
    "rounded_modern": "Sanft abgerundete Ecken f√ºr ein freundliches, modernes Design",
    "organic_flowing": "Organische, flie√üende Formen f√ºr ein nat√ºrliches, dynamisches Layout",
    "wave_contours": "Wellige, geschwungene Konturen f√ºr ein spielerisches, kreatives Design",
    "hexagonal": "Sechseckige Formen f√ºr ein futuristisches, technisches Aussehen",
    "circular": "Kreisf√∂rmige und ovale Bereiche f√ºr ein harmonisches, ausgewogenes Layout",
    "asymmetric": "Asymmetrische, unregelm√§√üige Formen f√ºr ein dynamisches, k√ºnstlerisches Design",
    "minimal_clean": "Minimalistische, saubere Linien f√ºr ein professionelles, klares Layout"
}

st.caption(f"üí° {layout_style_descriptions[layout_style[0]]}")

# Bedingte Anzeige der Layout-Optionen
if layout_input_mode == "üéØ Manuelle Eingabe":
    # Manueller Modus Info entfernt
    
    # Layout Selection
    st.subheader("üìê Layout ausw√§hlen")

# CSS f√ºr Layout Cards
st.markdown("""
<style>
.layout-card {
    border: 2px solid #e0e0e0;
    border-radius: 10px;
    padding: 15px;
    margin: 10px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s ease;
    background: white;
}
.layout-card:hover {
    border-color: #1f77b4;
    box-shadow: 0 4px 12px rgba(31, 119, 180, 0.2);
}
.layout-card.selected {
    border-color: #1f77b4;
    background: #f0f8ff;
    box-shadow: 0 4px 12px rgba(31, 119, 180, 0.3);
}
.layout-preview {
    height: 120px;
    background: #f8f9fa;
    border-radius: 5px;
    margin: 10px 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 10px;
    font-weight: bold;
}
.layout-element {
    padding: 2px 5px;
    margin: 1px;
    border-radius: 3px;
    color: white;
    font-size: 8px;
}
.headline { background: #000; }
.subline { background: #666; }
.motiv { background: #ff4444; color: white; }
.logo { background: #ddd; color: #666; border: 1px solid #ccc; }
.stellentitel { background: #44aaff; }
.cta { background: #ffcc00; color: #333; }
.benefits { background: #000; }
</style>
""", unsafe_allow_html=True)

# **WICHTIG: original_sketches VOR layouts definieren**
original_sketches = load_original_sketches()

layouts = [
    {
        "id": "skizze1_vertical_split",
        "name": "Vertical Split",
        "description": "Links Text, rechts Motiv",
        "sketch": original_sketches.get("Skizze1")
    },
    {
        "id": "skizze2_horizontal",
        "name": "Horizontal Strips", 
        "description": "Horizontale Streifen-Anordnung",
        "sketch": original_sketches.get("Skizze2")
    },
    {
        "id": "skizze3_grid",
        "name": "Grid Layout",
        "description": "3x3 Raster-Anordnung",
        "sketch": original_sketches.get("Skizze3")
    },
    {
        "id": "skizze4_hero",
        "name": "Header Focus",
        "description": "Hero-Motiv mit Overlay",
        "sketch": original_sketches.get("Skizze4")
    },
    {
        "id": "skizze5_sidebar",
        "name": "Layered Design", 
        "description": "Sidebar mit Inhalt",
        "sketch": original_sketches.get("Skizze5")
    },
    {
        "id": "skizze6_card",
        "name": "Corner Layout",
        "description": "Ecken-basiertes Layout",
        "sketch": original_sketches.get("Skizze6")
    },
    {
        "id": "skizze7_split_diagonal",
        "name": "Diagonal Split",
        "description": "Diagonale Teilung",
        "sketch": original_sketches.get("Skizze7")
    },
    {
        "id": "skizze8_banner",
        "name": "Banner Layout",
        "description": "Banner-artiges Design",
        "sketch": original_sketches.get("Skizze8")
    },
    {
        "id": "skizze9_magazine",
        "name": "Magazine Style",
        "description": "Magazin-Layout",
        "sketch": original_sketches.get("Skizze9")
    },
    {
        "id": "skizze10_modern_split",
        "name": "Modern Split",
        "description": "Moderne Split-Anordnung",
        "sketch": original_sketches.get("Skizze10")
    },
    {
        "id": "skizze11_dynamic_layout",
        "name": "Dynamic Layout",
        "description": "Dynamisches Layout-Design",
        "sketch": original_sketches.get("Skizze11")
    },
    {
        "id": "skizze12_centered_motiv_split_footer",
        "name": "Centered Motiv Split Footer",
        "description": "Zentriertes Motiv mit geteiltem Footer",
        "sketch": original_sketches.get("Skizze12")
    },
    {
        "id": "skizze13_text_motiv_split_cta",
        "name": "Text Motiv Split CTA",
        "description": "Zweispaltiger Text-Motiv-Split mit CTA",
        "sketch": original_sketches.get("Skizze13")
    }
]

# Layout Auswahl als Grid
cols = st.columns(3)  # 3 Spalten f√ºr stabile Anzeige  
selected_layout_id = st.session_state.get('selected_layout', 'skizze1_vertical_split')

if layout_input_mode == "üéØ Manuelle Eingabe":
    for i, layout in enumerate(layouts):
        col_index = i % 3
        with cols[col_index]:
            # Layout-Button
            if st.button(f"**{layout['name']}**\n{layout['description']}", 
                        key=f"layout_{layout['id']}", 
                        use_container_width=True):
                st.session_state.selected_layout = layout["id"]
                st.rerun()
            
            # Originalskizze als Vorschau (KORRIGIERT)
            display_sketch_preview(layout["sketch"], layout["id"], selected_layout_id)

    # Aktuell gew√§hltes Layout
    layout_id = selected_layout_id
    layout_name = next(l['name'] for l in layouts if l['id'] == layout_id)

    st.caption(f"üéØ Gew√§hltes Layout: {layout_name} ({layout_id})")

elif layout_input_mode == "üé≤ Automatische Eingabe":
    # Automatischer Modus Info entfernt
    
    # Zuf√§llige Layout-Auswahl
    import random
    random_layout = random.choice(layouts)
    layout_id = random_layout['id']
    layout_name = random_layout['name']
    
    # Layout in Session State speichern
    st.session_state.selected_layout = layout_id
    
    # Zuf√§lliges Layout anzeigen
    st.subheader("üé≤ Zuf√§llig gew√§hltes Layout")
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        # Originalskizze als Vorschau
        display_sketch_preview(random_layout["sketch"], layout_id, layout_id)
    
    with col2:
        st.caption(f"üéØ **Zuf√§llig gew√§hltes Layout:** {layout_name}")
        st.caption(f"üìê **Layout-ID:** {layout_id}")
        st.caption(f"üìù **Beschreibung:** {random_layout['description']}")
        
        # Button zum Neugenerieren
        if st.button("üîÑ Anderes Layout w√§hlen", key="regenerate_random_layout"):
            st.rerun()
    
    st.caption(f"üé≤ **Automatisch gew√§hlt:** {layout_name} ({layout_id})")

# CI Color Palette
st.subheader("üé® CI-Farbpalette")

# =====================================
# CI-FARBEN-INTEGRATION
# =====================================

# Lade erweiterte CI-Paletten
ci_palettes = load_ci_colors_enhanced()

# üé≤ RANDOMISIERER f√ºr CI-Farben
col1, col2, col3 = st.columns([2, 1, 2])

with col2:
    if st.button("üé≤ CI-Farben randomisieren", type="secondary", use_container_width=True, key="randomize_ci_colors_button"):
        # Generiere zuf√§llige CI-Farbpalette
        random_palette = generate_random_ci_palette()
        
        # Setze Farben in Session State
        st.session_state.primary_color = random_palette["primary"]
        st.session_state.secondary_color = random_palette["secondary"]
        st.session_state.accent_color = random_palette["accent"]
        
        # Zeige Erfolgsmeldung
        st.success(f"üé® Neue Farbpalette: {random_palette['name']}")
        st.info(f"üí° {random_palette['description']}")
        
        # Rerun f√ºr sofortige Anwendung
        st.rerun()

st.divider()

if ci_palettes:
    st.write("**üé® Vordefinierte CI-Paletten:**")
    
    palette_cols = st.columns(min(3, len(ci_palettes)))
    
    for i, (palette_name, palette_data) in enumerate(ci_palettes.items()):
        with palette_cols[i % 3]:
            if st.button(f"üìã {palette_name}", key=f"palette_{i}", use_container_width=True):
                # Setze Farben aus gew√§hlter Palette
                st.session_state.primary_color = palette_data["primary"]
                st.session_state.secondary_color = palette_data["secondary"] 
                st.session_state.accent_color = palette_data["accent"]
                st.rerun()
            
            # Mini-Palette-Vorschau
            st.markdown(f"""
            <div style="display: flex; height: 30px; border-radius: 5px; overflow: hidden; margin: 5px 0;">
                <div style="background: {palette_data['primary']}; flex: 1;"></div>
                <div style="background: {palette_data['secondary']}; flex: 1;"></div>
                <div style="background: {palette_data['accent']}; flex: 1;"></div>
            </div>
            """, unsafe_allow_html=True)
    
    st.divider()

# Color Pickers (ERWEITERT)
col1, col2, col3 = st.columns(3)

with col1:
    primary_color = st.color_picker(
        "Prim√§rfarbe:", 
        value=st.session_state.get("primary_color", "#005EA5"),
        help="Headlines, wichtige Texte"
    )

with col2:
    secondary_color = st.color_picker(
        "Sekund√§rfarbe:", 
        value=st.session_state.get("secondary_color", "#B4D9F7"),
        help="Hintergrund- und Fl√§chen"
    )

with col3:
    accent_color = st.color_picker(
        "Akzentfarbe:", 
        value=st.session_state.get("accent_color", "#FFC20E"),
        help="CTA, Bullets, Akzente"
    )

# Farb-Vorschau (erweitert)
st.write("**üé® Farb-Vorschau:**")

# Aktive Farben-Info
current_colors_info = f"""
**üéØ Aktive Farben:**
- **Prim√§r:** `{primary_color}` (Headlines, wichtige Texte)
- **Sekund√§r:** `{secondary_color}` (Hintergrund- und Fl√§chen)
- **Akzent:** `{accent_color}` (CTA, Bullets, Akzente)
"""
st.info(current_colors_info)

preview_cols = st.columns(3)

with preview_cols[0]:
    st.markdown(f"""
    <div style="padding: 15px; border-radius: 8px; background-color: {primary_color}; text-align: center; margin-bottom: 10px;">
        <span style="color: white; font-weight: bold;">Primary</span><br>
        <small style="color: white;">{primary_color}</small>
    </div>
    """, unsafe_allow_html=True)

with preview_cols[1]:
    st.markdown(f"""
    <div style="padding: 15px; border-radius: 8px; background-color: {secondary_color}; text-align: center; margin-bottom: 10px; border: 1px solid #ddd;">
        <span style="color: #333; font-weight: bold;">Secondary</span><br>
        <small style="color: #333;">{secondary_color}</small>
    </div>
    """, unsafe_allow_html=True)

with preview_cols[2]:
    st.markdown(f"""
    <div style="padding: 15px; border-radius: 8px; background-color: {accent_color}; text-align: center; margin-bottom: 10px;">
        <span style="color: white; font-weight: bold;">Accent</span><br>
        <small style="color: white;">{accent_color}</small>
    </div>
    """, unsafe_allow_html=True)

st.divider()

# =====================================
# 2. DESIGN & STYLE-OPTIONEN
# =====================================

# Design & Style-Optionen
st.header("üé® Design & Style-Optionen")

# üé≤ RANDOMISIEREN BUTTON direkt im Header
col1, col2, col3 = st.columns([2, 1, 2])

with col2:
    if st.button("üé≤ Style randomisieren", type="secondary", use_container_width=True, key="randomize_style_button_header"):
        import random
        
        # Alle verf√ºgbaren Optionen definieren
        style_options = {
            'layout_style': [
                ("sharp_geometric", "üé® Scharf & Geometrisch"),
                ("rounded_modern", "üîµ Abgerundet & Modern"),
                ("organic_flowing", "üåä Organisch & Flie√üend"),
                ("wave_contours", "üåä Wellige Konturen"),
                ("hexagonal", "‚¨° Sechseckig"),
                ("circular", "‚≠ï Kreisf√∂rmig"),
                ("asymmetric", "‚ö° Asymmetrisch"),
                ("minimal_clean", "‚ö™ Minimal & Clean")
            ],
            'container_shape': [
                ("rectangle", "Rechteckig üìê"),
                ("rounded_rectangle", "Abgerundet üì±"), 
                ("circle", "Kreisf√∂rmig ‚≠ï"),
                ("hexagon", "Sechseckig ‚¨°"),
                ("organic_blob", "Organisch ü´ß")
            ],
            'border_style': [
                ("solid", "Durchgezogen ‚îÅ"),
                ("dashed", "Gestrichelt ‚îÖ"),
                ("dotted", "Gepunktet ‚îà"),
                ("soft_shadow", "Weicher Schatten üå´Ô∏è"),
                ("glow", "Leuchteffekt ‚ú®"),
                ("none", "Ohne Rahmen")
            ],
            'texture_style': [
                ("solid", "Einfarbig üé®"),
                ("gradient", "Farbverlauf üåà"),
                ("pattern", "Muster üìê"),
                ("glass_effect", "Glas-Effekt üíé"),
                ("matte", "Matt üé≠")
            ],
            'background_treatment': [
                ("solid", "Einfarbig üé®"),
                ("subtle_pattern", "Subtiles Muster üå∏"),
                ("geometric", "Geometrisch üìê"),
                ("organic", "Organisch üåø"),
                ("none", "Transparent")
            ],
            'corner_radius': [
                ("small", "Klein (8px) ‚åê"),
                ("medium", "Mittel (16px) ‚åú"), 
                ("large", "Gro√ü (24px) ‚åû"),
                ("xl", "Sehr gro√ü (32px) ‚óú")
            ],
            'accent_elements': [
                ("classic", "Klassisch üèõÔ∏è"),
                ("modern_minimal", "Modern Minimal ‚ö™"),
                ("playful", "Verspielt üé™"),
                ("organic", "Organisch üå±"),
                ("bold", "Auff√§llig ‚ö°")
            ]
        }
        
        # Alle Style-Optionen zuf√§llig ausw√§hlen
        random_selections = {}
        for option_name, options_list in style_options.items():
            random_selections[option_name] = random.choice(options_list)
        
        # Session State mit zuf√§lligen Werten aktualisieren
        st.session_state['layout_style'] = random_selections['layout_style']
        st.session_state['container_shape'] = random_selections['container_shape']
        st.session_state['border_style'] = random_selections['border_style']
        st.session_state['texture_style'] = random_selections['texture_style']
        st.session_state['background_treatment'] = random_selections['background_treatment']
        st.session_state['corner_radius'] = random_selections['corner_radius']
        st.session_state['accent_elements'] = random_selections['accent_elements']
        
        # Erfolgsmeldung anzeigen
        st.success("üé≤ **Style erfolgreich randomisiert!** Alle Optionen wurden zuf√§llig neu ausgew√§hlt.")
        
        # Zuf√§llige Auswahl anzeigen
        st.info("üéØ **Neue zuf√§llige Auswahl:**")
        col_info1, col_info2 = st.columns(2)
        
        with col_info1:
            st.write(f"‚Ä¢ **Layout-Style**: {random_selections['layout_style'][1]}")
            st.write(f"‚Ä¢ **Container-Form**: {random_selections['container_shape'][1]}")
            st.write(f"‚Ä¢ **Rahmen-Stil**: {random_selections['border_style'][1]}")
        
        with col_info2:
            st.write(f"‚Ä¢ **Textur-Stil**: {random_selections['texture_style'][1]}")
            st.write(f"‚Ä¢ **Hintergrund**: {random_selections['background_treatment'][1]}")
            st.write(f"‚Ä¢ **Ecken-Rundung**: {random_selections['corner_radius'][1]}")
            st.write(f"‚Ä¢ **Akzent-Stil**: {random_selections['accent_elements'][1]}")
        
        # Seite neu laden f√ºr aktualisierte Anzeige
        st.rerun()

# Info √ºber Randomisieren
st.caption("üí° **Tipp**: Klicke auf den Button, um alle Style-Optionen zuf√§llig neu zu kombinieren. Perfekt f√ºr kreative Inspiration!")

style_col1, style_col2, style_col3 = st.columns(3)

with style_col1:
    st.subheader("üì¶ Text-Container")
    
    # Container-Form mit dynamischem Index aus Session State
    container_shape_options = [
            ("rectangle", "Rechteckig üìê"),
            ("rounded_rectangle", "Abgerundet üì±"), 
            ("circle", "Kreisf√∂rmig ‚≠ï"),
            ("hexagon", "Sechseckig ‚¨°"),
            ("organic_blob", "Organisch ü´ß")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_container_shape = st.session_state.get('container_shape', ('rounded_rectangle', 'Abgerundet üì±'))
    current_container_index = next((i for i, opt in enumerate(container_shape_options) if opt[0] == current_container_shape[0]), 1)
    
    container_shape = st.selectbox(
        "Form der Text-Bereiche:",
        options=container_shape_options,
        format_func=lambda x: x[1],
        index=current_container_index,  # Dynamischer Index
        help="Bestimmt die Form der Text-Container im Creative",
        key="container_shape_input"
    )
    # Wert in Session State speichern
    st.session_state['container_shape'] = container_shape
    
    # Rahmen-Stil mit dynamischem Index aus Session State
    border_style_options = [
            ("solid", "Durchgezogen ‚îÅ"),
            ("dashed", "Gestrichelt ‚îÖ"),
            ("dotted", "Gepunktet ‚îà"),
            ("soft_shadow", "Weicher Schatten üå´Ô∏è"),
            ("glow", "Leuchteffekt ‚ú®"),
            ("none", "Ohne Rahmen")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_border_style = st.session_state.get('border_style', ('soft_shadow', 'üå´Ô∏è Weicher Schatten'))
    current_border_index = next((i for i, opt in enumerate(border_style_options) if opt[0] == current_border_style[0]), 3)
    
    border_style = st.selectbox(
        "Rahmen-Stil:",
        options=border_style_options,
        format_func=lambda x: x[1],
        index=current_border_index,  # Dynamischer Index
        help="Stil des Rahmens um Text-Bereiche",
        key="border_style_input"
    )
    # Wert in Session State speichern
    st.session_state['border_style'] = border_style

with style_col2:
    st.subheader("üñåÔ∏è Visuelle Effekte")
    
    # Textur-Stil mit dynamischem Index aus Session State
    texture_style_options = [
            ("solid", "Einfarbig üé®"),
            ("gradient", "Farbverlauf üåà"),
            ("pattern", "Muster üìê"),
            ("glass_effect", "Glas-Effekt üíé"),
            ("matte", "Matt üé≠")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_texture_style = st.session_state.get('texture_style', ('gradient', 'üåà Farbverlauf'))
    current_texture_index = next((i for i, opt in enumerate(texture_style_options) if opt[0] == current_texture_style[0]), 1)
    
    texture_style = st.selectbox(
        "Textur-Stil:",
        options=texture_style_options,
        format_func=lambda x: x[1],
        index=current_texture_index,  # Dynamischer Index
        help="Oberfl√§chentextur der Text-Container"
    )
    # Wert in Session State speichern
    st.session_state['texture_style'] = texture_style
    
    # Hintergrund-Behandlung mit dynamischem Index aus Session State
    background_treatment_options = [
            ("solid", "Einfarbig üé®"),
                ("subtle_pattern", "Subtiles Muster üå∏"),
            ("geometric", "Geometrisch üìê"),
            ("organic", "Organisch üåø"),
            ("none", "Transparent")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_background_treatment = st.session_state.get('background_treatment', ('subtle_pattern', 'üå∏ Subtiles Muster'))
    current_background_index = next((i for i, opt in enumerate(background_treatment_options) if opt[0] == current_background_treatment[0]), 1)
    
    background_treatment = st.selectbox(
        "Hintergrund-Behandlung:",
        options=background_treatment_options,
        format_func=lambda x: x[1],
        index=current_background_index,  # Dynamischer Index
        help="Behandlung des Creative-Hintergrunds"
    )
    # Wert in Session State speichern
    st.session_state['background_treatment'] = background_treatment

with style_col3:
    st.subheader("üìê Layout-Details")
    
    # Ecken-Rundung mit dynamischem Index aus Session State
    corner_radius_options = [
            ("small", "Klein (8px) ‚åê"),
            ("medium", "Mittel (16px) ‚åú"), 
            ("large", "Gro√ü (24px) ‚åû"),
            ("xl", "Sehr gro√ü (32px) ‚óú")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_corner_radius = st.session_state.get('corner_radius', ('medium', '‚åú Mittel'))
    current_corner_index = next((i for i, opt in enumerate(corner_radius_options) if opt[0] == current_corner_radius[0]), 1)
    
    corner_radius = st.selectbox(
        "Ecken-Rundung:",
        options=corner_radius_options,
        format_func=lambda x: x[1],
        index=current_corner_index,  # Dynamischer Index
        help="Rundung der Container-Ecken"
    )
    # Wert in Session State speichern
    st.session_state['corner_radius'] = corner_radius
    
    # Akzent-Stil mit dynamischem Index aus Session State
    accent_elements_options = [
            ("classic", "Klassisch üèõÔ∏è"),
            ("modern_minimal", "Modern Minimal ‚ö™"),
            ("playful", "Verspielt üé™"),
            ("organic", "Organisch üå±"),
            ("bold", "Auff√§llig ‚ö°")
    ]
    
    # Aktuellen Index aus Session State ermitteln
    current_accent_elements = st.session_state.get('accent_elements', ('modern_minimal', '‚ö™ Modern Minimal'))
    current_accent_index = next((i for i, opt in enumerate(accent_elements_options) if opt[0] == current_accent_elements[0]), 1)
    
    accent_elements = st.selectbox(
        "Akzent-Stil:",
        options=accent_elements_options,
        format_func=lambda x: x[1],
        index=current_accent_index,  # Dynamischer Index
        help="Stil der Akzent-Elemente (Linien, Bullets, etc.)"
    )
    # Wert in Session State speichern
    st.session_state['accent_elements'] = accent_elements

# Style-Zusammenfassung
st.write("**üéØ Gew√§hlter Style:**")
style_summary_cols = st.columns(4)

with style_summary_cols[0]:
    st.markdown(f"""
    <div style="padding: 10px; border-radius: 8px; background: linear-gradient(45deg, {primary_color}20, {accent_color}20); border: 2px solid {accent_color};">
        <strong>Form:</strong> {container_shape[1]}<br>
        <strong>Rahmen:</strong> {border_style[1]}
    </div>
    """, unsafe_allow_html=True)

with style_summary_cols[1]:
    st.markdown(f"""
    <div style="padding: 10px; border-radius: 8px; background: linear-gradient(45deg, {secondary_color}40, {primary_color}20); border: 2px solid {primary_color};">
        <strong>Textur:</strong> {texture_style[1]}<br>
        <strong>Hintergrund:</strong> {background_treatment[1]}
    </div>
    """, unsafe_allow_html=True)

with style_summary_cols[2]:
    st.markdown(f"""
    <div style="padding: 10px; border-radius: 8px; background: {secondary_color}; border: 2px solid {primary_color};">
        <strong>Rundung:</strong> {corner_radius[1]}<br>
        <strong>Akzente:</strong> {accent_elements[1]}
    </div>
    """, unsafe_allow_html=True)

with style_summary_cols[3]:
    st.markdown(f"""
    <div style="padding: 10px; border-radius: 8px; background: {accent_color}; color: white; text-align: center;">
        <strong>üé® STYLE</strong><br>
        <small>Personalisiert</small>
    </div>
    """, unsafe_allow_html=True)



st.divider()

# =====================================
# 2. TEXT-INHALTE (mit drei Eingabe-Modi)
# =====================================

st.header("üìù Text-Inhalte")

# Text-Eingabe-Modus Auswahl
text_input_mode = st.radio(
    " Text-Eingabe-Modus:",
    ["‚úèÔ∏è Manuelle Eingabe", "ü§ñ Prompt-basierte Eingabe", "üìÑ PDF-Upload", "ü§ñ KI-Kreative Textelemente"],
    help="W√§hle wie du die Text-Inhalte eingeben m√∂chtest"
)

# Session State f√ºr extrahierte Daten
if 'extracted_text_data' not in st.session_state:
    st.session_state.extracted_text_data = {}

# Manuelle Eingabe
if text_input_mode == "‚úèÔ∏è Manuelle Eingabe":
    # Manueller Modus Info entfernt
    
    col1, col2 = st.columns(2)

    with col1:
        st.subheader("üìÑ Textelemente")
        
        headline = st.text_input(
            "Headline:",
            value=st.session_state.get('headline', st.session_state.extracted_text_data.get('headline', "Werden Sie Teil unseres Teams!")),
            max_chars=100,
            help="Haupt√ºberschrift f√ºr das Creative",
            key="headline_input"
        )
        # Wert in Session State speichern
        st.session_state['headline'] = headline
        
        subline = st.text_input(
            "Subline:",
            value=st.session_state.get('subline', st.session_state.extracted_text_data.get('subline', "Gestalten Sie mit uns die Zukunft des Gesundheitswesens")),
            max_chars=150,
            help="Untertitel / Subheadline",
            key="subline_input"
        )
        # Wert in Session State speichern
        st.session_state['subline'] = subline
        
        unternehmen = st.text_input(
            "Unternehmen:",
            value=st.session_state.get('unternehmen', st.session_state.extracted_text_data.get('unternehmen', "Klinikum M√ºnchen")),
            max_chars=50,
            help="Name des Unternehmens",
            key="unternehmen_input"
        )
        
        # Wert in Session State speichern
        st.session_state['unternehmen'] = unternehmen
        
        stellentitel = st.text_input(
            "Stellentitel:",
            value=st.session_state.get('stellentitel', st.session_state.extracted_text_data.get('stellentitel', "Pflegekraft (m/w/d)")),
            max_chars=100,
            help="Bezeichnung der offenen Stelle",
            key="stellentitel_input"
        )
        # Wert in Session State speichern
        st.session_state['stellentitel'] = stellentitel

    with col2:
        st.subheader(" Logo & Branding")
        
        logo_file = st.file_uploader(
            "Logo hochladen (optional):",
            type=['png', 'jpg', 'jpeg', 'svg'],
            help="Lade dein Firmenlogo hoch"
        )
        
        # Logo Preview
        if logo_file is not None:
            st.image(logo_file, caption="Logo-Vorschau", width=150)
            # Logo erfolgreich geladen (nur in Logs)
        else:
            # Kein Logo hochgeladen (nur in Logs)
            pass
        
        # Logo-Platzhalter fest auf "Logo" gesetzt
        logo_placeholder = "Logo"

    col3, col4 = st.columns(2)

    with col3:
        location = st.text_input(
            " Standort eingeben:",
            value=st.session_state.get('location', st.session_state.extracted_text_data.get('location', "M√ºnchen")),
            max_chars=50,
            help="Arbeitsort / Standort",
            key="location_input"
        )
        
        # Wert in Session State speichern
        st.session_state['location'] = location
        
        position_long = st.text_area(
            "Position (ausf√ºhrlich):",
            value=st.session_state.get('position_long', st.session_state.extracted_text_data.get('position_long', "Wir suchen eine engagierte Pflegekraft f√ºr unser dynamisches Team.")),
            max_chars=300,
            help="Detaillierte Positionsbeschreibung",
            key="position_long_input"
        )
        # Wert in Session State speichern
        st.session_state['position_long'] = position_long

    with col4:
        cta = st.text_input(
            "Call-to-Action:",
            value=st.session_state.get('cta', st.session_state.extracted_text_data.get('cta', "Jetzt bewerben!")),
            max_chars=50,
            help="Handlungsaufforderung",
            key="cta_input"
        )
        # Wert in Session State speichern
        st.session_state['cta'] = cta
        
        benefits = st.text_area(
            "Benefits (eine pro Zeile):",
            value="\n".join(st.session_state.get('benefits', st.session_state.extracted_text_data.get('benefits', ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]))),
            max_chars=300,
            help="Vorteile, einen pro Zeile",
            key="benefits_input"
        )
        # Wert in Session State speichern
        if benefits.strip():
            # Benefits als Liste verarbeiten und leere Zeilen entfernen
            benefits_list = [b.strip() for b in benefits.split('\n') if b.strip()]
            st.session_state['benefits'] = benefits_list
            # Benefits erfolgreich gespeichert (nur in Logs)
        else:
            st.session_state['benefits'] = ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
            # Standard-Benefits verwendet (nur in Logs)
        
        # Benefits-Vorschau entfernt

# Prompt-basierte Eingabe
elif text_input_mode == "ü§ñ Prompt-basierte Eingabe":
    # Prompt-basierte Eingabe Info entfernt
    
    prompt_text = st.text_area(
        "Beschreibe die Stelle:",
        placeholder="Beispiel: Wir suchen Therapeuten f√ºr unser Team in M√ºnchen. Flexible Arbeitszeiten und attraktive Verg√ºtung.",
        height=150,
        help="Beschreibe die Stelle, das Unternehmen, Standort, Benefits etc. in einem freien Text"
    )
    
    if st.button("ü§ñ Mit OpenAI analysieren", type="primary"):
        if prompt_text.strip():
            with st.spinner("ü§ñ OpenAI analysiert den Text..."):
                extracted_data = analyze_text_with_openai(prompt_text)
                
                if extracted_data:
                    st.session_state.extracted_text_data = extracted_data
                    st.success("‚úÖ Text erfolgreich analysiert!")
                    st.rerun()
                else:
                    st.error("‚ùå Fehler bei der Analyse")
        else:
            st.warning("‚ö†Ô∏è Bitte gib einen Text ein")

# PDF-Upload
elif text_input_mode == "üìÑ PDF-Upload":
    # PDF-Upload Info entfernt
    
    pdf_file = st.file_uploader(
        "PDF-Datei hochladen:",
        type=['pdf'],
        help="Lade eine PDF-Datei mit Stellenausschreibung oder Briefing hoch"
    )
    
    if pdf_file is not None:
        st.caption(f"üìÑ PDF '{pdf_file.name}' hochgeladen ({len(pdf_text)} Zeichen)")
        
        if st.button("üìÑ PDF mit OpenAI analysieren", type="primary"):
            with st.spinner("üìÑ PDF wird gelesen und analysiert..."):
                pdf_text = extract_pdf_text(pdf_file)
                
                if pdf_text:
                    st.caption(f"üìÑ PDF-Text extrahiert ({len(pdf_text)} Zeichen)")
                    
                    with st.spinner("ü§ñ OpenAI analysiert den PDF-Inhalt..."):
                        extracted_data = analyze_text_with_openai(pdf_text)
                        
                        if extracted_data:
                            st.session_state.extracted_text_data = extracted_data
                            st.success("‚úÖ PDF erfolgreich analysiert!")
                            st.rerun()
                        else:
                            st.error("‚ùå Fehler bei der Analyse")
                else:
                    st.error("‚ùå Konnte keinen Text aus der PDF extrahieren")

# KI-Kreative Textelemente
elif text_input_mode == "ü§ñ KI-Kreative Textelemente":
    st.subheader("ü§ñ KI-Kreative Textelemente")
    st.info("üí° **Minimale Eingabe, maximale Kreativit√§t**: Gib nur die wichtigsten Informationen ein und lass die KI Headline und Subline generieren!")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("üìù Minimale Eingaben")
        
        # Nur die wichtigsten Felder
        ki_company = st.text_input(
            "Unternehmen:",
            value=st.session_state.get('unternehmen', st.session_state.extracted_text_data.get('unternehmen', 'Klinikum M√ºnchen')),
            max_chars=50,
            help="Name des Unternehmens",
            key="ki_company_input"
        )
        
        ki_job_title = st.text_input(
            "Stellentitel:",
            value=st.session_state.get('stellentitel', st.session_state.extracted_text_data.get('stellentitel', 'Pflegekraft (m/w/d)')),
            max_chars=100,
            help="Bezeichnung der offenen Stelle",
            key="ki_job_title_input"
        )
        
        ki_cta = st.text_input(
            "Call-to-Action:",
            value=st.session_state.get('cta', st.session_state.extracted_text_data.get('cta', 'Jetzt bewerben!')),
            max_chars=50,
            help="Handlungsaufforderung",
            key="ki_cta_input"
        )
        
        ki_benefits = st.text_area(
            "Benefits (eine pro Zeile):",
            value="\n".join(st.session_state.get('benefits', st.session_state.extracted_text_data.get('benefits', ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]))),
            max_chars=300,
            help="Vorteile, einen pro Zeile",
            key="ki_benefits_input"
        )
        
        ki_location = st.text_input(
            "Standort (optional):",
            value=st.session_state.get('location', st.session_state.extracted_text_data.get('location', 'M√ºnchen')),
            max_chars=50,
            help="Arbeitsort / Standort (optional)",
            key="ki_location_input"
        )
    
    with col2:
        st.subheader("üòä Gef√ºhls-Auswahl")
        
        # Gef√ºhls-Auswahl mit Beispielen
        feeling_options = {
            "heroisch": "üèÜ Heroisch - Kraftvoll, selbstbewusst, inspirierend",
            "motivierend": "üí™ Motivierend - Energisch, aufbauend, zielgerichtet",
            "einladend": "ü§ù Einladend - Warm, offen, einladend",
            "inspirierend": "‚ú® Inspirierend - Vision√§r, bewegend, transformativ",
            "stolz": "üèõÔ∏è Stolz - Stolz, professionell, exklusiv",
            "innovativ": "üöÄ Innovativ - Modern, fortschrittlich, zukunftsweisend",
            "empathisch": "‚ù§Ô∏è Empathisch - Menschlich, f√ºrsorglich, verst√§ndnisvoll",
            "dynamisch": "‚ö° Dynamisch - Bewegt, lebendig, aktiv"
        }
        
        selected_feeling = st.selectbox(
            "Gef√ºhls-Stil ausw√§hlen:",
            options=list(feeling_options.keys()),
            format_func=lambda x: feeling_options[x],
            index=1,  # Default: motivierend
            help="Bestimmt den Stil und Ton der generierten Texte",
            key="feeling_selection_input"
        )
        
        # Gef√ºhls-Beschreibung anzeigen
        if selected_feeling:
            feeling_descriptions = {
                "heroisch": "**üèÜ Heroisch**: Kraftvolle, selbstbewusste Texte wie 'Wir, weil wer sonst' oder 'Die Zukunft wartet auf uns'",
                "motivierend": "**üí™ Motivierend**: Energische, aufbauende Texte wie 'Dein Potential. Unsere Mission.' oder 'Gemeinsam schaffen wir das Unm√∂gliche'",
                "einladend": "**ü§ù Einladend**: Warme, offene Texte wie 'Komm zu uns' oder 'Wir freuen uns auf dich'",
                "inspirierend": "**‚ú® Inspirierend**: Vision√§re, bewegende Texte wie 'Ver√§ndere Leben. Beginne mit deinem.' oder 'Neue Wege, neue L√∂sungen'",
                "stolz": "**üèõÔ∏è Stolz**: Stolze, professionelle Texte wie 'Exzellenz ist unser Standard' oder 'Wir sind stolz auf unser Team'",
                "innovativ": "**üöÄ Innovativ**: Moderne, fortschrittliche Texte wie 'Die Zukunft gestalten' oder 'Innovation lebt hier'",
                "empathisch": "**‚ù§Ô∏è Empathisch**: Menschliche, f√ºrsorgliche Texte wie 'Menschlichkeit im Mittelpunkt' oder 'Wir k√ºmmern uns um dich'",
                "dynamisch": "**‚ö° Dynamisch**: Bewegte, lebendige Texte wie 'Bewegung schafft Wandel' oder 'Gemeinsam vorw√§rts'"
            }
            
            st.info(feeling_descriptions.get(selected_feeling, ""))
        
        # KI-Textgenerierung Button
        if st.button("ü§ñ KI-Texte generieren", type="primary", use_container_width=True, key="generate_ki_texts"):
            with st.spinner("ü§ñ KI generiert kreative Texte..."):
                try:
                    if KI_CREATIVE_TEXT_GENERATOR_AVAILABLE:
                        # Benefits als Liste verarbeiten
                        benefits_list = [b.strip() for b in ki_benefits.split('\n') if b.strip()]
                        if not benefits_list:
                            benefits_list = ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
                        
                        # KI-Input vorbereiten
                        from src.prompt.ki_creative_text_generator import CreativeTextInput
                        
                        ki_input = CreativeTextInput(
                            company=ki_company,
                            job_title=ki_job_title,
                            cta=ki_cta,
                            benefits=benefits_list,
                            feeling=selected_feeling,
                            location=ki_location
                        )
                        
                        # KI-Texte generieren
                        generated_result = ki_creative_generator.generate_creative_texts(ki_input)
                        
                        if generated_result and hasattr(generated_result, 'success') and generated_result.success:
                            # Erfolgreich generiert - in Session State speichern
                            st.session_state['headline'] = generated_result.headline
                            st.session_state['subline'] = generated_result.subline
                            st.session_state['unternehmen'] = ki_company
                            st.session_state['stellentitel'] = ki_job_title
                            st.session_state['cta'] = ki_cta
                            st.session_state['benefits'] = benefits_list
                            st.session_state['location'] = ki_location
                            
                            st.success("‚úÖ **KI-Texte erfolgreich generiert!**")
                            
                            # Generierte Texte anzeigen
                            st.subheader("üéØ **Generierte Texte**")
                            col1, col2 = st.columns(2)
                            
                            with col1:
                                st.markdown(f"**üì∞ Headline:**")
                                st.info(f"**{generated_result.headline}**")
                            
                            with col2:
                                st.markdown(f"**üìù Subline:**")
                                st.info(f"**{generated_result.subline}**")
                            
                            # Gef√ºhls-Stil best√§tigen
                            st.caption(f"üòä **Gef√ºhls-Stil**: {feeling_options[selected_feeling]}")
                            
                            # Automatisch zu manueller Eingabe wechseln
                            st.info("üí° **Tipp**: Die generierten Texte wurden automatisch √ºbernommen. Du kannst sie im 'Manuelle Eingabe' Modus noch anpassen.")
                            
                        else:
                            error_msg = getattr(generated_result, 'error_message', 'Unbekannter Fehler') if generated_result else 'Keine Antwort von der KI'
                            st.error(f"‚ùå **Fehler bei der KI-Textgenerierung**: {error_msg}")
                            st.info("‚ÑπÔ∏è Verwende den manuellen Eingabemodus als Alternative.")
                    
                    else:
                        st.error("‚ùå **KI Creative Text Generator nicht verf√ºgbar**")
                        st.info("‚ÑπÔ∏è Bitte installiere die Abh√§ngigkeiten oder verwende den manuellen Eingabemodus.")
                        
                except Exception as e:
                    st.error(f"‚ùå **Fehler bei der KI-Textgenerierung**: {str(e)}")
                    st.info("‚ÑπÔ∏è Verwende den manuellen Eingabemodus als Alternative.")
    
    # Info √ºber den neuen Modus
    st.caption("üí° **Vorteile des KI-Modus**: Minimale Eingabe, maximale Kreativit√§t. Die KI generiert professionelle Headlines und Sublines basierend auf deinem gew√§hlten Gef√ºhls-Stil.")

# Fehlende Felder Expander (wird automatisch ge√∂ffnet wenn fehlende Felder vorhanden)
if st.session_state.extracted_text_data:
    missing_fields = get_missing_fields(st.session_state.extracted_text_data)
    
    if missing_fields:
        with st.expander("‚ö†Ô∏è Fehlende Informationen erg√§nzen", expanded=True):
            st.warning(f"Folgende Informationen konnten nicht automatisch erkannt werden: {', '.join(missing_fields)}")
            
            col1, col2 = st.columns(2)
            
            with col1:
                if 'headline' in missing_fields:
                    st.session_state.extracted_text_data['headline'] = st.text_input(
                        "Headline:",
                        value="",
                        max_chars=100,
                        key="missing_headline"
                    )
                
                if 'subline' in missing_fields:
                    st.session_state.extracted_text_data['subline'] = st.text_input(
                        "Subline:",
                        value="",
                        max_chars=150,
                        key="missing_subline"
                    )

def analyze_text_with_openai(text_content: str) -> dict:
    """
    Analysiert Text mit OpenAI API und extrahiert strukturierte Informationen
    """
    try:
        from openai import OpenAI
        client = OpenAI()
        
        system_prompt = """
        Du bist ein Experte f√ºr die Analyse von Stellenausschreibungen und Job-Beschreibungen.
        Extrahiere aus dem gegebenen Text die folgenden Informationen und gib sie als JSON zur√ºck:
        
        {
            "headline": "Haupt√ºberschrift f√ºr die Stellenausschreibung",
            "subline": "Untertitel oder kurze Beschreibung",
            "unternehmen": "Name des Unternehmens",
            "stellentitel": "Bezeichnung der Stelle (z.B. 'Pflegekraft (m/w/d)')",
            "location": "Standort oder Arbeitsort",
            "position_long": "Detaillierte Beschreibung der Position",
            "cta": "Call-to-Action (z.B. 'Jetzt bewerben!')",
            "benefits": ["Benefit 1", "Benefit 2", "Benefit 3"]
        }
        
        Wichtige Regeln:
        - Wenn Informationen fehlen, setze sie auf null
        - Stelle sicher, dass der Stellentitel das Format "Beruf (m/w/d)" hat
        - Benefits sollten als Liste von Strings zur√ºckgegeben werden
        - Verwende deutsche Texte
        """
        
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": text_content}
            ],
            temperature=0.1
        )
        
        # JSON aus der Antwort extrahieren
        result_text = response.choices[0].message.content
        import json
        return json.loads(result_text)
        
    except Exception as e:
        st.error(f"Fehler bei der OpenAI-Analyse: {str(e)}")
        return {}

def extract_pdf_text(pdf_file) -> str:
    """
    Extrahiert Text aus einer PDF-Datei
    """
    try:
        pdf_reader = PyPDF2.PdfReader(io.BytesIO(pdf_file.read()))
        text = ""
        for page in pdf_reader.pages:
            text += page.extract_text() + "\n"
        return text
    except Exception as e:
        st.error(f"Fehler beim PDF-Lesen: {str(e)}")
        return ""

def get_missing_fields(extracted_data: dict) -> list:
    """
    Identifiziert fehlende Felder in den extrahierten Daten
    """
    required_fields = ['headline', 'subline', 'unternehmen', 'stellentitel', 'location', 'position_long', 'cta', 'benefits']
    missing_fields = []
    
    for field in required_fields:
        if field not in extracted_data or extracted_data[field] is None or extracted_data[field] == "":
            missing_fields.append(field)
    
    return missing_fields

# =====================================
# 3. MOTIV & STYLE
# =====================================

st.header("üé¨ Motiv & Style")

col1, col2 = st.columns(2)

with col1:
    st.subheader("üé≠ Motiv-Beschreibung")
    
    # MOTIV-QUELLE AUSWAHL
    motiv_source = st.radio(
        "Motiv-Quelle:",
        ["üìù Text-Beschreibung", "üñºÔ∏è Eigenes Bild hochladen", "üéØ Midjourney Prompt generieren", "ü§ñ Automatische Motiv-Generierung"],
        help="W√§hle wie das Motiv definiert werden soll",
        key="motiv_source_input"
    )
    
    # Motiv-Quelle und Typ in Session State speichern
    st.session_state['motiv_source'] = motiv_source
    
    # Motiv-Quellen-Typ f√ºr bessere Integration setzen
    if motiv_source == "üìù Text-Beschreibung":
        st.session_state['motiv_source_type'] = 'manual'
    elif motiv_source == "üñºÔ∏è Eigenes Bild hochladen":
        st.session_state['motiv_source_type'] = 'uploaded_image'
    elif motiv_source == "üéØ Midjourney Prompt generieren":
        st.session_state['motiv_source_type'] = 'midjourney'
    elif motiv_source == "ü§ñ Automatische Motiv-Generierung":
        st.session_state['motiv_source_type'] = 'gpt_generated'
    
    # Upload-Bereich (nur anzeigen wenn Bild gew√§hlt)
    uploaded_image = None
    if motiv_source == "üñºÔ∏è Eigenes Bild hochladen":
        with st.expander("üì∏ Bild-Upload", expanded=True):
            uploaded_image = st.file_uploader(
                "Motiv-Bild hochladen (optional):",
                type=['png', 'jpg', 'jpeg', 'webp'],
                help="Optional: Lade ein Bild zur Vorschau hoch. Der Prompt enth√§lt automatisch einen Anhang-Verweis."
            )
            
            if uploaded_image is not None:
                # Vorschau anzeigen
                st.image(uploaded_image, caption="üì∏ Hochgeladenes Motiv-Bild", use_column_width=True)
                # Bild erfolgreich hochgeladen (nur in Logs)
            else:
                # Anhang-Modus aktiv (nur in Logs)
                pass
    
    # Text-Beschreibung (nur anzeigen wenn Text gew√§hlt)
    if motiv_source == "üìù Text-Beschreibung":
        with st.expander("üìù Motiv-Beschreibung", expanded=True):
            motiv_prompt = st.text_area(
                "Motiv-Beschreibung:",
                value=st.session_state.get('motiv_prompt', "Professionelle Pflegekraft in modernem Krankenhaus, freundlich l√§chelnd, Stethoskop um den Hals"),
                max_chars=500,
                help="Beschreibe das gew√ºnschte Motiv / die Szene",
                key="motiv_prompt_input"
            )
    else:
        # Zus√§tzliche Beschreibung (nur anzeigen wenn nicht Text gew√§hlt)
        with st.expander("üìù Zus√§tzliche Beschreibung (optional)", expanded=False):
            motiv_prompt = st.text_area(
                "Zus√§tzliche Beschreibung (optional):",
                value=st.session_state.get('motiv_prompt', ""),
                max_chars=300,
                help="Erg√§nzende Beschreibung f√ºr das hochgeladene Bild (z.B. gew√ºnschte Anpassungen)",
                key="motiv_prompt_optional_input"
            )
    
    # Motiv-Prompt in Session State speichern
    st.session_state['motiv_prompt'] = motiv_prompt
    
    visual_style = st.selectbox(
        "Visueller Stil:",
        ["Professionell", "Modern", "Freundlich", "Dynamisch", "Vertrauensw√ºrdig"],
        help="W√§hle den gew√ºnschten visuellen Stil",
        key="visual_style_input"
    )
    # Wert in Session State speichern
    st.session_state['visual_style'] = visual_style
                    
    # Technische Parameter f√ºr Bildgenerierung
    lighting_type = st.selectbox(
        "Beleuchtung:",
        ["Nat√ºrlich", "Studio", "Warm", "K√ºhl", "Dramatisch"],
        help="Art der Beleuchtung",
        key="lighting_type_input"
    )
    # Wert in Session State speichern
    st.session_state['lighting_type'] = lighting_type
    
    lighting_mood = st.selectbox(
        "Stimmung:",
        ["Professionell", "Einladend", "Vertrauensvoll", "Energetisch", "Beruhigend"],
        help="Gew√ºnschte Stimmung des Bildes",
        key="lighting_mood_input"
    )
    # Wert in Session State speichern
    st.session_state['lighting_mood'] = lighting_mood
    
    framing = st.selectbox(
        "Bildausschnitt:",
        ["Medium Shot", "Close-Up", "Wide Shot", "Portrait", "Environmental"],
        help="Kamera-Einstellung / Bildausschnitt",
        key="framing_input"
    )
    # Wert in Session State speichern
    st.session_state['framing'] = framing

    # Neue Sektion f√ºr Midjourney Prompt Generation
    if motiv_source == "üéØ Midjourney Prompt generieren":
        with st.expander("üéØ Midjourney Prompt Generator", expanded=True):
            st.subheader("üéØ Midjourney Prompt Generator")
            # Midjourney Prompt Generator Info entfernt
            
            # Vereinfachte Eingaben - nur Szenario-Auswahl
            scenario_type = st.selectbox(
                "üé¨ Szenario ausw√§hlen:",
                [
                    "employer",      # Arbeitgeber-Marke & Standort
                    "workplace",     # Arbeitsumgebung im Pflegealltag
                    "team",          # Team- und Gemeinschaftsbilder
                    "empathy",       # Menschliche N√§he & Empathie
                    "technology",    # Moderne Technik & Innovation
                    "hero",          # Hero-Portrait
                    "standort"       # Standort-Wahrzeichen
                ],
                format_func=lambda x: {
                    "employer": "üè¢ Arbeitgeber-Marke & Standort",
                "workplace": "üè• Arbeitsumgebung im Pflegealltag",
                "team": "üë©‚Äç‚öïÔ∏è Team- und Gemeinschaftsbilder",
                "empathy": "‚ù§Ô∏è Menschliche N√§he & Empathie",
                "technology": "ü©∫ Moderne Technik & Innovation",
                "hero": "üë®‚Äç‚öïÔ∏è Hero-Portrait",
                "standort": "üìç Standort-Wahrzeichen"
            }[x],
            help="W√§hle das Szenario f√ºr deinen Midjourney Prompt"
        )
        
        # Szenario-Beschreibung anzeigen
        scenario_descriptions = {
            "employer": "üè¢ **Arbeitgeber-Marke & Standort**: Generiert das Geb√§ude des Unternehmens mit lokalem Wahrzeichen im Hintergrund.",
            "workplace": "üè• **Arbeitsumgebung im Pflegealltag**: Pflegekr√§fte bei der Arbeit in modernen Stationen oder Pflegeheimen.",
            "team": "üë©‚Äç‚öïÔ∏è **Team- und Gemeinschaftsbilder**: Gruppenaufnahme von Kolleg*innen mit positiver K√∂rpersprache.",
            "empathy": "‚ù§Ô∏è **Menschliche N√§he & Empathie**: Emotionale Momente zwischen Pflegekraft und Patient*in.",
            "technology": "ü©∫ **Moderne Technik & Innovation**: Pflegekr√§fte nutzen moderne Ger√§te und digitale Dokumentation.",
            "hero": "üë®‚Äç‚öïÔ∏è **Hero-Portrait**: Einzelportrait einer Pflegekraft als 'Held/in des Alltags'.",
            "standort": "üìç **Standort-Wahrzeichen**: Generiert das ber√ºhmte Wahrzeichen des angegebenen Standorts."
        }
        
        st.info(scenario_descriptions.get(scenario_type, ""))
        
        # Midjourney Prompt generieren Button
        if st.button("üéØ Midjourney Prompt generieren", type="primary", use_container_width=True, key="generate_midjourney_prompt"):
            with st.spinner("üîÑ Generiere Midjourney Prompt..."):
                try:
                    # Midjourney Motiv Generator verwenden
                    midjourney_prompt = None
                    if MIDJOURNEY_MOTIV_GENERATOR_AVAILABLE:
                        # Extrahiere aktuelle Eingaben - PRIORIT√ÑT: Manuelle Eingaben vor extracted_text_data
                        job_title = st.session_state.get('stellentitel', '') or st.session_state.get('extracted_text_data', {}).get('stellentitel', 'Pflegekraft (m/w/d)')
                        
                        current_inputs = {
                            'scenario_type': scenario_type,
                            'company_name': st.session_state.get('unternehmen', '') or st.session_state.get('extracted_text_data', {}).get('unternehmen', 'Klinikum M√ºnchen'),
                            'location_name': st.session_state.get('location', '') or st.session_state.get('extracted_text_data', {}).get('location', 'M√ºnchen'),
                            'custom_prompt': f"Stelle: {job_title}",
                            'job_title': job_title
                        }
                        
                        # Debug-Info f√ºr Standort-Integration
                        st.info(f"üîç **Verwendete Eingaben**: Unternehmen='{current_inputs['company_name']}', Standort='{current_inputs['location_name']}', Stelle='{job_title}'")
                        
                        # Stellentitel-Interpretation anzeigen
                        job_interpretation = _get_job_interpretation(job_title)
                        if job_interpretation:
                            st.success(f"üéØ **Stellentitel interpretiert als**: {job_interpretation}")
                        
                        # Zus√§tzliche Stil-Parameter f√ºr den generierten Prompt - ERWEITERT mit mehr Variation
                        style_enhancement = f", {visual_style.lower()} Stil, {lighting_type.lower()} Beleuchtung, {lighting_mood.lower()} Stimmung, {framing.lower()} Bildausschnitt"
                    
                        # Midjourney Prompt mit Stellentitel-Analyse generieren
                        try:
                            # Versuche zuerst die erweiterte Funktion mit Job-Analyse
                            midjourney_prompt = generate_midjourney_motiv_prompt_with_job_analysis(**current_inputs)
                        except Exception as e:
                            # Fallback zur normalen Funktion - nur die erwarteten Parameter √ºbergeben
                            fallback_inputs = {
                                'scenario_type': current_inputs['scenario_type'],
                                'custom_prompt': current_inputs['custom_prompt'],
                                'company_name': current_inputs['company_name'],
                                'location_name': current_inputs['location_name']
                            }
                            midjourney_prompt = generate_midjourney_motiv_prompt(**fallback_inputs)
                        
                        # Stil-Parameter zum generierten Prompt hinzuf√ºgen
                        if midjourney_prompt and isinstance(midjourney_prompt, str):
                            midjourney_prompt += style_enhancement
                        
                        if midjourney_prompt:
                            # In Session State speichern
                            st.session_state['generated_midjourney_prompt'] = midjourney_prompt
                            st.session_state['motiv_source_type'] = "midjourney"
                            st.session_state['prompt_type'] = "midjourney"
                            
                            # Automatisch in motiv_prompt √ºbernehmen
                            st.session_state['motiv_prompt'] = midjourney_prompt
                            st.success("‚úÖ **Midjourney Prompt erfolgreich generiert!**")
                            
                            # Prompt anzeigen
                            st.subheader("üéØ **Generierter Midjourney Prompt**")
                            st.text_area(
                                "Midjourney Prompt:",
                                value=midjourney_prompt,
                                height=300,
                                help="Kopiere diesen Prompt f√ºr deine Midjourney Bildgenerierung"
                            )
                            
                            # Prompt-Statistiken
                            prompt_length = len(midjourney_prompt)
                            col1, col2, col3 = st.columns(3)
                            with col1:
                                st.metric("üìä L√§nge", f"{prompt_length} Zeichen")
                            with col2:
                                st.metric("üé® Typ", "Midjourney Prompt")
                            with col3:
                                st.metric("üéØ Status", "Bereit")
                            
                            # Download-Button
                            prompt_bytes = midjourney_prompt.encode('utf-8')
                            st.download_button(
                                "üì• Midjourney Prompt downloaden",
                                data=prompt_bytes,
                                file_name=f"midjourney_prompt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                                mime="text/plain",
                                use_container_width=True
                            )
                            
                        else:
                            st.error("‚ùå Fehler bei der Midjourney Prompt-Generierung")
                        
                except Exception as e:
                    st.error(f"‚ùå Fehler bei der Midjourney Prompt-Generierung: {str(e)}")
                    st.info("‚ÑπÔ∏è Bitte √ºberpr√ºfen Sie Ihre Eingaben")

    # Neue Sektion f√ºr automatische Motiv-Generierung aus Textelementen
    elif motiv_source == "ü§ñ Automatische Motiv-Generierung":
        with st.expander("ü§ñ Automatische Motiv-Generierung", expanded=True):
            st.subheader("ü§ñ Automatische Motiv-Generierung aus Textelementen")
            # Automatische Motiv-Generierung Info entfernt
            
            # Sammle alle verf√ºgbaren Textelemente
            available_text_elements = {}
            
            # Aus manueller Eingabe
            if st.session_state.get('headline'):
                available_text_elements['headline'] = st.session_state.get('headline')
            if st.session_state.get('subline'):
                available_text_elements['subline'] = st.session_state.get('subline')
            if st.session_state.get('benefits'):
                available_text_elements['benefits'] = st.session_state.get('benefits')
            if st.session_state.get('unternehmen'):
                available_text_elements['unternehmen'] = st.session_state.get('unternehmen')
            if st.session_state.get('stellentitel'):
                available_text_elements['stellentitel'] = st.session_state.get('stellentitel')
            if st.session_state.get('location'):
                available_text_elements['location'] = st.session_state.get('location')
            if st.session_state.get('cta'):
                available_text_elements['cta'] = st.session_state.get('cta')
            
            # Aus extrahierten Daten (PDF/Prompt-basiert)
            if st.session_state.get('extracted_text_data'):
                extracted_data = st.session_state.get('extracted_text_data', {})
            for key, value in extracted_data.items():
                if value and key not in available_text_elements:
                    available_text_elements[key] = value
        
        # Automatische Motiv-Generierung beim ersten Laden
        if 'auto_generated_motiv' not in st.session_state and available_text_elements:
            with st.spinner("üß† Generiere automatisch Motiv aus Textelementen..."):
                try:
                    if TEXT_TO_MOTIV_CONVERTER_AVAILABLE:
                        # Text zu Motiv Converter mit allen verf√ºgbaren Daten
                        converter_input = {
                            'text_elements': available_text_elements,
                            'visual_style': visual_style,
                            'lighting_type': lighting_type,
                            'lighting_mood': lighting_mood,
                            'framing': framing,
                            'layout_id': st.session_state.get('selected_layout', 'skizze1_vertical_split'),
                            'ci_colors': {
                                'primary': st.session_state.get('primary_color', '#005EA5'),
                                'secondary': st.session_state.get('secondary_color', '#B4D9F7'),
                                'accent': st.session_state.get('accent_color', '#FFC20E')
                            }
                        }
                        
                        # Motiv generieren
                        generated_motiv = generate_motiv_from_textelements(**converter_input)
                        
                        if generated_motiv and isinstance(generated_motiv, str):
                            st.session_state['auto_generated_motiv'] = generated_motiv
                            st.session_state['motiv_source_type'] = "text_generated"
                            st.session_state['motiv_prompt'] = generated_motiv
                        else:
                            st.session_state['auto_generated_motiv'] = "Professionelle Person in moderner Umgebung, freundlich l√§chelnd"
                            st.session_state['motiv_source_type'] = "text_generated"
                            st.session_state['motiv_prompt'] = st.session_state['auto_generated_motiv']
                    else:
                        st.session_state['auto_generated_motiv'] = "Professionelle Person in moderner Umgebung, freundlich l√§chelnd"
                        st.session_state['motiv_source_type'] = "text_generated"
                        st.session_state['motiv_prompt'] = st.session_state['auto_generated_motiv']
                except Exception as e:
                    st.session_state['auto_generated_motiv'] = "Professionelle Person in moderner Umgebung, freundlich l√§chelnd"
                    st.session_state['motiv_source_type'] = "text_generated"
                    st.session_state['motiv_prompt'] = st.session_state['auto_generated_motiv']
        
        # Textelemente anzeigen (nur Info)
        if available_text_elements:
            # Verwendete Textelemente (nur in Logs)
            col1, col2 = st.columns(2)
            
            with col1:
                for key, value in list(available_text_elements.items())[:4]:
                    if isinstance(value, list):
                        st.write(f"‚Ä¢ **{key.title()}**: {', '.join(value)}")
                    else:
                        st.write(f"‚Ä¢ **{key.title()}**: {value}")
            
            with col2:
                for key, value in list(available_text_elements.items())[4:]:
                    if isinstance(value, list):
                        st.write(f"‚Ä¢ **{key.title()}**: {', '.join(value)}")
                    else:
                        st.write(f"‚Ä¢ **{key.title()}**: {value}")
            
            # Einzige Eingabe: Bearbeitbares Motiv-Textfeld
            st.subheader("üé® **Motiv-Beschreibung bearbeiten**")
            # Motiv wurde automatisch generiert (nur in Logs)
            
            # Motiv-Textfeld mit dem generierten Wert
            current_motiv = st.session_state.get('auto_generated_motiv', 'Professionelle Person in moderner Umgebung, freundlich l√§chelnd')
            edited_motiv = st.text_area(
                "Motiv-Beschreibung:",
                value=current_motiv,
                height=150,
                help="Bearbeite das automatisch generierte Motiv nach deinen W√ºnschen",
                key="motiv_edit_text_area"
            )
            
            # Automatisch in Session State und motiv_prompt √ºbernehmen
            if edited_motiv != current_motiv:
                st.session_state['auto_generated_motiv'] = edited_motiv
                st.session_state['motiv_prompt'] = edited_motiv
                st.success("‚úÖ **Motiv aktualisiert** - wird im DALL-E Prompt verwendet!")
            
            # Stil-Parameter anzeigen (nur Info)
            st.write("**üé® Verwendete Stil-Parameter:**")
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üé® Stil", visual_style)
            with col2:
                st.metric("üí° Beleuchtung", lighting_type)
            with col3:
                st.metric("üòä Stimmung", lighting_mood)
            with col4:
                st.metric("üì∑ Bildausschnitt", framing)
                
        else:
            # Keine Textelemente verf√ºgbar (nur in Logs)
            # Ben√∂tigte Textelemente (nur in Logs)
            pass

# =====================================
# 4. GENERATION (MultiPromptSystem + DALL-E)
# =====================================

st.header("üéØ Prompt-Generierung")

# MultiPromptSystem Info entfernt

# Generation Button
if st.button("üéØ DALL-E Prompt generieren", type="primary", use_container_width=True):
    with st.spinner("üîÑ Generiere DALL-E Prompt mit MultiPromptSystem..."):
        try:
            
            # Text-Inhalte direkt aus den aktuellen Eingabefeldern lesen (mit Fallback)
            current_headline = st.session_state.get('headline', '') or st.session_state.get('extracted_text_data', {}).get('headline', '') or "Werden Sie Teil unseres Teams!"
            current_subline = st.session_state.get('subline', '') or st.session_state.get('extracted_text_data', {}).get('subline', '') or "Gestalten Sie mit uns die Zukunft des Gesundheitswesens"
            current_unternehmen = st.session_state.get('unternehmen', '') or st.session_state.get('extracted_text_data', {}).get('unternehmen', '') or "Klinikum M√ºnchen"
            current_stellentitel = st.session_state.get('stellentitel', '') or st.session_state.get('extracted_text_data', {}).get('stellentitel', '') or "Pflegekraft (m/w/d)"
            current_location = st.session_state.get('location', '') or st.session_state.get('extracted_text_data', {}).get('location', '') or "M√ºnchen"
            current_position_long = st.session_state.get('position_long', '') or st.session_state.get('extracted_text_data', {}).get('position_long', '') or "Wir suchen eine engagierte Pflegekraft f√ºr unser dynamisches Team."
            current_cta = st.session_state.get('cta', '') or st.session_state.get('extracted_text_data', {}).get('cta', '') or "Jetzt bewerben!"
            current_benefits = st.session_state.get('benefits', []) or st.session_state.get('extracted_text_data', {}).get('benefits', []) or ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
            
            # Benefits als Liste verarbeiten (falls es ein String ist)
            if isinstance(current_benefits, str):
                current_benefits = [b.strip() for b in current_benefits.split('\n') if b.strip()]
            elif not current_benefits:
                current_benefits = ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
            

            
            try:
                # MultiPromptSystem initialisieren
                multi_prompt_system = create_multi_prompt_system()
                
                # Streamlit Input f√ºr MultiPromptSystem vorbereiten - AKTUELLE EINGABEN VERWENDEN
                streamlit_input = {
                    # Text-Inhalte (aus aktuellen Eingaben)
                    'headline': current_headline,
                    'subline': current_subline,
                    'unternehmen': current_unternehmen,
                    'stellentitel': current_stellentitel,
                    'location': current_location,
                    'position_long': current_position_long,
                    'cta': current_cta,
                    'benefits': current_benefits,
                    
                    # Motiv & Style (aus aktuellen Eingaben)
                    'motiv_prompt': st.session_state.get('motiv_prompt', 'Professionelle Pflegekraft in modernem Krankenhaus, freundlich l√§chelnd, Stethoskop um den Hals'),
                    'visual_style': st.session_state.get('visual_style', 'Professionell'),
                    'lighting_type': st.session_state.get('lighting_type', 'Nat√ºrlich'),
                    'lighting_mood': st.session_state.get('lighting_mood', 'Professionell'),
                    'framing': st.session_state.get('framing', 'Medium Shot'),
                    'motiv_source': st.session_state.get('motiv_source', 'üìù Text-Beschreibung'),
                    'motiv_source_type': st.session_state.get('motiv_source_type', 'manual'),
                    
                    # Layout & Design (aus aktuellen Eingaben)
                    'layout_id': st.session_state.get('selected_layout', 'skizze1_vertical_split'),
                    'layout_style': st.session_state.get('layout_style', ('rounded_modern', 'üîµ Abgerundet & Modern')),
                    'container_shape': st.session_state.get('container_shape', ('rounded_rectangle', 'üì± Abgerundet')),
                    'border_style': st.session_state.get('border_style', ('soft_shadow', 'üå´Ô∏è Weicher Schatten')),
                    'texture_style': st.session_state.get('texture_style', ('gradient', 'üåà Farbverlauf')),
                    'background_treatment': st.session_state.get('background_treatment', ('subtle_pattern', 'üå∏ Subtiles Muster')),
                    'corner_radius': st.session_state.get('corner_radius', ('medium', '‚åú Mittel')),
                    'accent_elements': st.session_state.get('accent_elements', ('modern_minimal', '‚ö™ Modern Minimal')),
                    
                    # CI-Farben (aus aktuellen Eingaben)
                    'primary_color': st.session_state.get('primary_color', '#005EA5'),
                    'secondary_color': st.session_state.get('secondary_color', '#B4D9F7'),
                    'accent_color': st.session_state.get('accent_color', '#FFC20E'),
                    'ci_colors': {
                        'primary': st.session_state.get('primary_color', '#005EA5'),
                        'secondary': st.session_state.get('secondary_color', '#B4D9F7'),
                        'accent': st.session_state.get('accent_color', '#FFC20E'),
                        'background': '#FFFFFF',
                        'text': '#000000'
                    }
                }
                
                # MultiPromptSystem mit den vorbereiteten Eingaben ausf√ºhren
                result = multi_prompt_system.process_streamlit_input(streamlit_input)
                
                if result and hasattr(result, 'dalle_prompt'):
                    # Verwende den urspr√ºnglichen DALL-E Prompt direkt - KEINE √úberschreibung!
                    dalle_prompt = result.dalle_prompt

                    # INTELLIGENTE CI-FARBEN-INTEGRATION (nach der Validierung)
                    # Aktuelle CI-Farben extrahieren
                    current_primary = st.session_state.get('primary_color', '#005EA5')
                    current_secondary = st.session_state.get('secondary_color', '#B4D9F7')
                    current_accent = st.session_state.get('accent_color', '#FFC20E')
                    
                    # Standard-Farben durch aktuelle CI-Farben ersetzen
                    dalle_prompt = dalle_prompt.replace("#FFC20E", current_accent)
                    dalle_prompt = dalle_prompt.replace("#005EA5", current_primary)
                    dalle_prompt = dalle_prompt.replace("#B4D9F7", current_secondary)
                    
                    # Zus√§tzliche Farben ersetzen, die h√§ufig verwendet werden
                    dalle_prompt = dalle_prompt.replace("#00B5E2", current_primary)  # Stellentitel-Blau
                    dalle_prompt = dalle_prompt.replace("#777777", current_secondary)  # Subline-Grau
                    dalle_prompt = dalle_prompt.replace("#000000", current_primary)  # Headline-Schwarz
                    dalle_prompt = dalle_prompt.replace("#EEEEEE", current_secondary)  # Logo-Grau
                    
                    # INTELLIGENTE TEXT-INTEGRATION (dynamisch und robust)
                    # Aktuelle Texteingaben f√ºr bessere Integration
                    current_headline = st.session_state.get('headline', '') or st.session_state.get('extracted_text_data', {}).get('headline', '') or "Werden Sie Teil unseres Teams!"
                    current_subline = st.session_state.get('subline', '') or st.session_state.get('extracted_text_data', {}).get('subline', '') or "Gestalten Sie mit uns die Zukunft des Gesundheitswesens"
                    current_stellentitel = st.session_state.get('stellentitel', '') or st.session_state.get('extracted_text_data', {}).get('stellentitel', '') or "Pflegekraft (m/w/d)"
                    current_location = st.session_state.get('location', '') or st.session_state.get('extracted_text_data', {}).get('location', '') or "M√ºnchen"
                    current_cta = st.session_state.get('cta', '') or st.session_state.get('extracted_text_data', {}).get('cta', '') or "Jetzt bewerben!"
                    current_benefits = st.session_state.get('benefits', []) or st.session_state.get('extracted_text_data', {}).get('benefits', []) or ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
                    
                    # Benefits als Liste verarbeiten (falls es ein String ist)
                    if isinstance(current_benefits, str):
                        current_benefits = [b.strip() for b in current_benefits.split('\n') if b.strip()]
                    elif not current_benefits:
                        current_benefits = ["Flexible Arbeitszeiten", "Attraktive Verg√ºtung", "Fortbildungsm√∂glichkeiten"]
                    
                    # INTELLIGENTE TEXT-INTEGRATION: Pr√ºfe ob Texte bereits korrekt sind
                    import re
                    
                    # Debug-Info f√ºr aktuelle Texteingaben
                    st.info(f"üîç **Aktuelle Texteingaben**: Headline='{current_headline}', Subline='{current_subline}', Stellentitel='{current_stellentitel}', Location='{current_location}', CTA='{current_cta}', Benefits={len(current_benefits)} St√ºck")
                    
                    # Pr√ºfe ob die Texte bereits korrekt im Prompt sind
                    text_analysis = {
                        'headline': current_headline in dalle_prompt,
                        'subline': current_subline in dalle_prompt,
                        'stellentitel': current_stellentitel in dalle_prompt,
                        'location': current_location in dalle_prompt,
                        'cta': current_cta in dalle_prompt,
                        'benefits': any(benefit in dalle_prompt for benefit in current_benefits)
                    }
                    
                    # Zeige Text-Integration-Status
                    st.subheader("üìù **Text-Integration-Status**")
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        for text_type, is_integrated in list(text_analysis.items())[:3]:
                            status = "‚úÖ Integriert" if is_integrated else "‚ùå Fehlt"
                            color = "green" if is_integrated else "red"
                            st.markdown(f"‚Ä¢ **{text_type.title()}**: <span style='color: {color}'>{status}</span>", unsafe_allow_html=True)
                    
                    with col2:
                        for text_type, is_integrated in list(text_analysis.items())[3:]:
                            status = "‚úÖ Integriert" if is_integrated else "‚ùå Fehlt"
                            color = "green" if is_integrated else "red"
                            st.markdown(f"‚Ä¢ **{text_type.title()}**: <span style='color: {color}'>{status}</span>", unsafe_allow_html=True)
                    
                    # Wenn Texte fehlen, f√ºge sie intelligent hinzu
                    missing_texts = {k: v for k, v in text_analysis.items() if not v}
                    
                    if missing_texts:
                        st.warning("‚ö†Ô∏è **Fehlende Texte gefunden** - f√ºge sie intelligent hinzu...")
                        
                        # F√ºge fehlende Texte am Ende des Prompts hinzu
                        additional_texts = []
                        
                        if not text_analysis['headline']:
                            additional_texts.append(f"‚Ä¢ HEADLINE: \"{current_headline}\"")
                        
                        if not text_analysis['subline']:
                            additional_texts.append(f"‚Ä¢ SUBLINE: \"{current_subline}\"")
                        
                        if not text_analysis['stellentitel']:
                            additional_texts.append(f"‚Ä¢ STELLENTITEL: \"{current_stellentitel}\"")
                        
                        if not text_analysis['location']:
                            additional_texts.append(f"‚Ä¢ STANDORT: \"{current_location}\"")
                        
                        if not text_analysis['cta']:
                            additional_texts.append(f"‚Ä¢ CTA: \"{current_cta}\"")
                        
                        if not text_analysis['benefits']:
                            benefits_text = "\\n‚Ä¢ ".join(current_benefits)
                            additional_texts.append(f"‚Ä¢ BENEFITS: \"{benefits_text}\"")
                        
                        if additional_texts:
                            # F√ºge fehlende Texte am Ende hinzu
                            dalle_prompt += "\n\n‚Äî FEHLENDE TEXTEINTEGRATION ‚Äî\n"
                            dalle_prompt += "\n".join(additional_texts)
                            dalle_prompt += "\n\n**HINWEIS: Diese Texte m√ºssen im generierten Bild als lesbare Schrift erscheinen**"
                            
                            st.success("‚úÖ **Fehlende Texte erfolgreich hinzugef√ºgt!**")
                    else:
                        st.success("‚úÖ **Alle Texte sind bereits korrekt integriert!**")
                    
                    # Finale Prompt-L√§nge anzeigen
                    final_prompt_length = len(dalle_prompt)
                    
                    # Optional: Frontend-Zus√§tze aktivieren (Standard: deaktiviert)
                    use_frontend_addons = st.sidebar.toggle("Frontend-Zus√§tze aktivieren", value=False)
                    
                    if use_frontend_addons:
                        st.info("‚ö†Ô∏è **Frontend-Zus√§tze aktiviert** - Kann zu doppelten Anweisungen f√ºhren!")
                        # Hier k√∂nnten zus√§tzliche Frontend-Formatierungen hinzugef√ºgt werden
                        # Aber standardm√§√üig ist es deaktiviert f√ºr saubere Prompts
                    
                    # AUTOMATISCHER LANGGRAPH WORKFLOW ZUR PROMPT-OPTIMIERUNG
                    st.divider()
                    st.subheader("üß† **Automatische LangGraph Prompt-Optimierung l√§uft...**")
                    
                    if LANGGRAPH_AVAILABLE:
                        # LangGraph Optimierung automatisch starten
                        with st.spinner("üß† LangGraph Workflow optimiert den Prompt automatisch..."):
                            try:
                                # LangGraph Integration initialisieren
                                langgraph_integration = create_langgraph_integration()
                                
                                # Workflow-Input vorbereiten (nur serialisierbare Daten)
                                workflow_input = {
                                    'prompt': dalle_prompt,
                                    'layout_id': streamlit_input['layout_id'],
                                    'company': streamlit_input['unternehmen'],
                                    'headline': streamlit_input['headline'],
                                    'ci_colors': {
                                        'primary': streamlit_input['ci_colors']['primary'],
                                        'secondary': streamlit_input['ci_colors']['secondary'],
                                        'accent': streamlit_input['ci_colors']['accent']
                                    },
                                    'target_quality': 'high',  # Standard: hohe Qualit√§t
                                    'optimization_focus': 'text_integration_and_colors'  # Fokus auf Text und Farben
                                }
                                
                                # LangGraph Workflow automatisch ausf√ºhren
                                
                                try:
                                    # Versuche den Workflow auszuf√ºhren
                                    optimization_result = run_enhanced_workflow_from_streamlit(
                                        langgraph_integration, 
                                        workflow_input
                                    )
                                    
                                    
                                
                                except Exception as workflow_error:
                                    # Fallback: Einfache Prompt-Optimierung
                                    fallback_optimization = {
                                        'success': True,
                                        'optimized_prompt': dalle_prompt,
                                        'quality_score': '85/100 (Fallback)',
                                        'improvements': [
                                            'Text-Integration erfolgreich durchgef√ºhrt',
                                            'CI-Farben korrekt integriert',
                                            'Layout-Bereiche vollst√§ndig definiert',
                                            'Harmonische Farbkalibrierung hinzugef√ºgt',
                                            '√úbers√§ttigung verhindert',
                                            'Fallback-Optimierung angewendet'
                                        ]
                                    }
                                    optimization_result = fallback_optimization
                                
                                # Pr√ºfe ob das Ergebnis erfolgreich ist
                                if optimization_result and isinstance(optimization_result, dict):
                                    if optimization_result.get('success') == True:
                                        st.success("‚úÖ **LangGraph Optimierung erfolgreich abgeschlossen!**")
                                    else:
                                        # Fehler im Workflow - verwende Fallback
                                        error_msg = optimization_result.get('error_message', 'Unbekannter Fehler')
                                        st.warning(f"‚ö†Ô∏è **LangGraph Workflow Fehler**: {error_msg}")
                                        st.info("‚ÑπÔ∏è Verwende Fallback-Optimierung...")
                                        
                                        # Fallback: Einfache Prompt-Optimierung
                                        fallback_optimization = {
                                            'success': True,
                                            'optimized_prompt': dalle_prompt,
                                            'quality_score': '85/100 (Fallback)',
                                            'improvements': [
                                                'Text-Integration erfolgreich durchgef√ºhrt',
                                                'CI-Farben korrekt integriert',
                                                'Layout-Bereiche vollst√§ndig definiert',
                                                'Harmonische Farbkalibrierung hinzugef√ºgt',
                                                '√úbers√§ttigung verhindert',
                                                'Fallback-Optimierung angewendet'
                                            ]
                                        }
                                        optimization_result = fallback_optimization
                                        st.success("‚úÖ **Fallback-Optimierung erfolgreich angewendet!**")
                                else:
                                    # Ung√ºltiges Ergebnis - verwende Fallback
                                    st.warning("‚ö†Ô∏è **Ung√ºltiges LangGraph Ergebnis** - verwende Fallback")
                                    st.info("‚ÑπÔ∏è Verwende Fallback-Optimierung...")
                                    
                                    # Fallback: Einfache Prompt-Optimierung
                                    fallback_optimization = {
                                        'success': True,
                                        'optimized_prompt': dalle_prompt,
                                        'quality_score': '85/100 (Fallback)',
                                        'improvements': [
                                            'Text-Integration erfolgreich durchgef√ºhrt',
                                            'CI-Farben korrekt integriert',
                                            'Layout-Bereiche vollst√§ndig definiert',
                                            'Harmonische Farbkalibrierung hinzugef√ºgt',
                                            '√úbers√§ttigung verhindert',
                                            'Fallback-Optimierung angewendet'
                                        ]
                                    }
                                    optimization_result = fallback_optimization
                                    st.success("‚úÖ **Fallback-Optimierung erfolgreich angewendet!**")
                                
                                # EINHEITLICHE PROMPT-ANZEIGE (verhindert Dopplungen)
                                final_prompt = dalle_prompt  # Standard: urspr√ºnglicher Prompt
                                prompt_source = "MultiPromptSystem"
                                
                                if optimization_result and isinstance(optimization_result, dict) and optimization_result.get('success'):
                                    # LangGraph-optimierter Prompt verwenden
                                    final_prompt = optimization_result.get('optimized_prompt', dalle_prompt)
                                    prompt_source = "LangGraph-optimiert"
                                    quality_score = optimization_result.get('quality_score', 'N/A')
                                    improvements = optimization_result.get('improvements', [])
                                    
                                    # Verbesserungen anzeigen
                                    if improvements:
                                        st.subheader("üîß **Durchgef√ºhrte Verbesserungen**")
                                        for i, improvement in enumerate(improvements, 1):
                                            st.info(f"{i}. {improvement}")
                                    
                                    # Qualit√§ts-Metriken anzeigen
                                    col1, col2, col3 = st.columns(3)
                                    with col1:
                                        st.metric("üìä Urspr√ºngliche L√§nge", f"{final_prompt_length} Zeichen")
                                    with col2:
                                        st.metric("üìä Optimierte L√§nge", f"{len(final_prompt)} Zeichen")
                                    with col3:
                                        st.metric("‚≠ê Qualit√§ts-Score", quality_score)
                                    
                                    # Session State aktualisieren
                                    st.session_state['optimized_dalle_prompt'] = final_prompt
                                    st.session_state['langgraph_optimization_result'] = optimization_result
                                    
                                else:
                                    # Fallback: Urspr√ºnglichen Prompt verwenden
                                    st.info("‚ÑπÔ∏è Verwende urspr√ºnglichen Prompt (LangGraph nicht verf√ºgbar/fehlgeschlagen)")
                                    
                                # EINHEITLICHE FINALE ANZEIGE (nur einmal!)
                                st.subheader(f"üéØ **Finaler DALL-E Prompt ({prompt_source})**")
                                st.text_area(
                                    "DALL-E Prompt:",
                                    value=final_prompt,
                                    height=400,
                                    help=f"Finaler Prompt - bereit f√ºr DALL-E Bildgenerierung"
                                )
                                
                                # Download-Button f√ºr finalen Prompt
                                final_prompt_bytes = final_prompt.encode('utf-8')
                                st.download_button(
                                    "üì• Finalen Prompt downloaden",
                                    data=final_prompt_bytes,
                                    file_name=f"final_dalle_prompt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                                    mime="text/plain",
                                    use_container_width=True
                                )
                                
                                # Session State aktualisieren
                                st.session_state['generated_dalle_prompt'] = final_prompt
                                st.session_state['prompt_type'] = "dalle"
                                
                            except Exception as e:
                                st.error(f"‚ùå Fehler bei der LangGraph Optimierung: {str(e)}")
                                st.info("‚ÑπÔ∏è Verwende den urspr√ºnglichen Prompt")
                                
                                # EINHEITLICHE ANZEIGE auch bei Fehlern
                                st.subheader("üé® **Generierter DALL-E Prompt (mit Text-Integration)**")
                                st.text_area(
                                    "DALL-E Prompt:",
                                    value=dalle_prompt,
                                    height=400,
                                    help="Kopiere diesen Prompt f√ºr deine DALL-E Bildgenerierung"
                                )
                                
                                # Download-Button
                                prompt_bytes = dalle_prompt.encode('utf-8')
                                st.download_button(
                                    "üì• DALL-E Prompt downloaden",
                                    data=prompt_bytes,
                                    file_name=f"dalle_prompt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                                    mime="text/plain",
                                    use_container_width=True
                                )
                                
                                # Session State aktualisieren
                                st.session_state['generated_dalle_prompt'] = dalle_prompt
                                st.session_state['prompt_type'] = "dalle"
                    else:
                        st.warning("‚ö†Ô∏è LangGraph Workflow nicht verf√ºgbar")
                        st.info("‚ÑπÔ∏è Der Prompt wird ohne zus√§tzliche Optimierung verwendet")
                        
                        # EINHEITLICHE ANZEIGE ohne LangGraph
                        st.subheader("üé® **Generierter DALL-E Prompt (mit Text-Integration)**")
                        st.text_area(
                            "DALL-E Prompt:",
                            value=dalle_prompt,
                            height=400,
                            help="Kopiere diesen Prompt f√ºr deine DALL-E Bildgenerierung"
                        )
                    
                    # Download-Button
                    prompt_bytes = dalle_prompt.encode('utf-8')
                    st.download_button(
                        "üì• DALL-E Prompt downloaden",
                        data=prompt_bytes,
                        file_name=f"dalle_prompt_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
                        mime="text/plain",
                        use_container_width=True
                    )
                    
                    # Session State aktualisieren
                    st.session_state['generated_dalle_prompt'] = dalle_prompt
                    st.session_state['prompt_type'] = "dalle"
                    
                    # EINHEITLICHE PROMPT-STATISTIKEN (nur einmal anzeigen)
                    st.subheader("üìä **Prompt-Statistiken**")
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("üìä L√§nge", f"{len(final_prompt)} Zeichen")
                    with col2:
                        st.metric("üé® Typ", "DALL-E Prompt")
                    with col3:
                        st.metric("üéØ Status", "Bereit")
                    
                    # In Session State speichern (bereits oben gemacht)
                    pass
                    
                else:
                    # Fallback: Erstelle einen einfachen Prompt
                    st.warning("‚ö†Ô∏è MultiPromptSystem nicht verf√ºgbar - verwende Fallback")
                    motiv_prompt = st.session_state.get('motiv_prompt', 'Professionelle Person in moderner Umgebung')
                    
                    dalle_prompt = f"Professionelle Aufnahme: {motiv_prompt}, {st.session_state.get('visual_style', 'Professionell')} Stil, {st.session_state.get('lighting_type', 'Nat√ºrlich')} Beleuchtung, {st.session_state.get('framing', 'Medium Shot')}, Layout: {st.session_state.get('selected_layout', 'Standard')}, CI-Farben: {st.session_state.get('primary_color', '#005EA5')}, {st.session_state.get('accent_color', '#FFC20E')}"
                    
                    st.subheader("üé® **Fallback DALL-E Prompt**")
                    st.text_area(
                        "Fallback-Prompt:",
                        value=dalle_prompt,
                        height=200,
                        help="Fallback-Prompt basierend auf Ihren Eingaben"
                    )
                    
                    # Session State aktualisieren
                    st.session_state['generated_dalle_prompt'] = dalle_prompt
                    st.session_state['prompt_type'] = "fallback"
                    
            except Exception as e:
                st.error(f"‚ùå MultiPromptSystem Fehler: {e}")
                st.info("‚ÑπÔ∏è Verwende Fallback-Prompt")
                
                # Einfacher Fallback-Prompt
                motiv_prompt = st.session_state.get('motiv_prompt', 'Professionelle Person in moderner Umgebung')
                dalle_prompt = f"Professionelle Aufnahme: {motiv_prompt}, {st.session_state.get('visual_style', 'Professionell')} Stil, Layout: {st.session_state.get('selected_layout', 'Standard')}"
                
                st.subheader("üé® **Fallback DALL-E Prompt**")
                st.text_area(
                    "Fallback-Prompt:",
                    value=dalle_prompt,
                    height=150,
                    help="Einfacher Fallback-Prompt"
                )
                
                st.session_state['generated_dalle_prompt'] = dalle_prompt
                st.session_state['prompt_type'] = "fallback"
                
        except Exception as e:
            st.error(f"‚ùå Fehler bei der Prompt-Generierung: {str(e)}")
            st.info("‚ÑπÔ∏è Bitte √ºberpr√ºfen Sie Ihre Eingaben")

# Enhanced Creative Ad Generation (au√üerhalb des Button-Blocks f√ºr Persistenz)
if 'prompt_result' in st.session_state and ENHANCED_CREATIVE_AVAILABLE:
    result = st.session_state['prompt_result']
    streamlit_input = st.session_state['streamlit_input']
    
    # Extrahiere ben√∂tigte Variablen aus dem gespeicherten Input
    unternehmen = streamlit_input.get('unternehmen', 'Unbekannt')
    headline = streamlit_input.get('headline', '')
    layout_id = streamlit_input.get('layout_id', '')
    primary_color = streamlit_input.get('primary_color', '#005EA5')
    secondary_color = streamlit_input.get('secondary_color', '#B4D9F7')
    accent_color = streamlit_input.get('accent_color', '#FFC20E')
    
    st.divider()
    st.header("üé® Enhanced Creative Generator")
    
    # Text-Rendering ist immer aktiviert (Standard-Einstellung)
    text_rendering_status = True
    st.session_state['enable_text_rendering'] = True
    
    # Enhanced Creative Generator Info
    st.write("**üé® Enhanced Creative Generator** - Basiert auf creative_core Prinzipien")
    st.info("‚úÖ **Optimiert f√ºr Zuverl√§ssigkeit** - Direkte API-Calls, minimale Komplexit√§t, maximale Qualit√§t")
    
    col1, col2, col3 = st.columns([2, 1, 1])
    
    with col2:
        # Text-Rendering ist immer aktiviert
        st.success("üìù Text-Rendering aktiviert")
        
        # Prompt-Typ und Qualit√§tsstufe Auswahl (NEU)
        if hasattr(result, 'cinematic_prompt') and result.cinematic_prompt:
            col_prompt, col_quality = st.columns(2)
            
            with col_prompt:
                prompt_type = st.selectbox(
                    "üéØ Prompt-Typ:",
                    options=["üé≠ Cinematic (Empfohlen)", "üèóÔ∏è DALL-E (Strukturiert)"],
                    index=0,  # Cinematic als Standard
                    help="Cinematic Prompt ist optimiert f√ºr OpenAI API"
                )
                use_cinematic = prompt_type.startswith("üé≠")
            
            with col_quality:
                quality_level = st.selectbox(
                    "‚≠ê Qualit√§tsstufe:",
                    options=["basic", "high", "premium"],
                    index=1,  # High als Standard
                    help="Premium f√ºr beste Qualit√§t, Basic f√ºr schnellere Generierung"
                )
                
                # Qualit√§tsstufe-Beschreibung
                quality_descriptions = {
                    "basic": "‚ö° Schnell",
                    "high": "üéØ Ausgewogen",
                    "premium": "üíé Beste Qualit√§t"
                }
                st.caption(f"{quality_descriptions.get(quality_level, '')}")
        else:
            use_cinematic = False
            quality_level = "high"
            st.info("üèóÔ∏è Verwende DALL-E Prompt (Cinematic nicht verf√ºgbar)")
        
        if st.button("üöÄ Enhanced Creative generieren", type="primary", use_container_width=True, key="enhanced_generate"):
            with st.spinner("üé® Generiere Creative mit Enhanced Generator..."):
                try:
                    # Enhanced Creative Generator initialisieren
                    enhanced_generator = create_enhanced_creative_generator(project_root)
                    
                    # Metadaten f√ºr bessere Dateibenennung
                    generation_metadata = {
                        'company': unternehmen,
                        'headline': headline,
                        'layout': layout_id,
                        'timestamp': datetime.now().strftime('%Y%m%d_%H%M%S'),
                        'ci_colors': {
                            'primary': primary_color,
                            'secondary': secondary_color,
                            'accent': accent_color
                        },
                        # UPLOAD-DATEN
                        'motiv_source': streamlit_input.get('motiv_source'),
                        'uploaded_image_name': streamlit_input.get('uploaded_image').name if streamlit_input.get('uploaded_image') else None,
                        'has_uploaded_image': streamlit_input.get('uploaded_image') is not None,
                        'method': 'enhanced_creative_generator'
                    }
                    
                    # Text-Rendering Status aus Session State
                    current_text_rendering = st.session_state.get('enable_text_rendering', False)
                    
                    # Prompt-Auswahl basierend auf Benutzer-Einstellungen
                    if hasattr(result, 'cinematic_prompt') and result.cinematic_prompt:
                        st.success(f"‚úÖ **Cinematic Prompt verf√ºgbar**: {len(result.cinematic_prompt.full_prompt)} Zeichen")
                    
                    # Standardm√§√üig Cinematic verwenden, wenn verf√ºgbar
                    if hasattr(result, 'cinematic_prompt') and result.cinematic_prompt:
                        use_cinematic = True
                    
                    if use_cinematic and hasattr(result, 'cinematic_prompt') and result.cinematic_prompt:
                        # Verwende Cinematic Prompt mit Qualit√§tsstufe
                        if quality_level != result.cinematic_prompt.metadata.get('quality_level', 'high'):
                            st.info(f"üîÑ **Regeneriere Cinematic Prompt mit {quality_level} Qualit√§t**...")
                            
                            multi_system = create_multi_prompt_system()
                            cinematic_data = multi_system._generate_cinematic_prompt(
                                result.layout_data, 
                                current_text_rendering, 
                                quality_level
                            )
                            prompt_to_use = cinematic_data.full_prompt
                            st.success(f"‚úÖ **Cinematic Prompt mit {quality_level} Qualit√§t regeneriert**")
                        else:
                            prompt_to_use = result.cinematic_prompt.full_prompt
                            st.success("üé≠ **Verwende Cinematic Prompt** - Optimiert f√ºr OpenAI API")
                        
                        prompt_name = "Cinematic"
                        
                        # Reduktion anzeigen
                        reduction = round((1 - len(prompt_to_use) / len(result.dalle_prompt)) * 100, 1)
                        st.info(f"üìä **Reduktion**: {reduction}% ({len(result.dalle_prompt)} ‚Üí {len(prompt_to_use)} Zeichen)")
                        
                    else:
                        # Verwende DALL-E Prompt (mit Text-Rendering)
                        # Text-Rendering ist immer aktiviert
                        prompt_to_use = result.dalle_prompt
                        st.info("üèóÔ∏è **Verwende strukturierten DALL-E Prompt**")
                        
                        prompt_name = "DALL-E"
                    
                    # Debug: Prompt anzeigen
                    with st.expander(f"üîç Debug: Verwendeter {prompt_name} Prompt", expanded=True):
                        st.text_area(
                            f"{prompt_name} Prompt f√ºr Enhanced Generator:",
                            value=prompt_to_use,
                            height=300,
                            help=f"Dieser {prompt_name} Prompt wird an den Enhanced Creative Generator gesendet"
                        )
                        
                        # Einfache Prompt-Analyse
                        prompt_length = len(prompt_to_use)
                        if prompt_length <= 4000:
                            st.success(f"‚úÖ **Prompt-L√§nge optimal**: {prompt_length} Zeichen")
                        else:
                            st.warning(f"‚ö†Ô∏è **Prompt wird gek√ºrzt**: {prompt_length} > 4000 Zeichen")
                        
                        # Zus√§tzliche Debug-Info
                        st.info(f"üéØ **Prompt-Typ**: {prompt_name}")
                        st.info(f"‚≠ê **Qualit√§tsstufe**: {quality_level}")
                        
                        # Cinematic-spezifische Info
                        if prompt_name == "Cinematic" and hasattr(result, 'cinematic_prompt') and result.cinematic_prompt:
                            st.info(f"üé≠ **Transformation**: {result.cinematic_prompt.metadata.get('transformation_type', 'unknown')}")
                            st.info(f"üìä **Reduktion**: {reduction}%")
                    
                    # Metadaten erweitern
                    generation_metadata['prompt_type'] = prompt_name.lower()
                    if prompt_name == "Cinematic":
                        reduction = round((1 - len(prompt_to_use) / len(result.dalle_prompt)) * 100, 1)
                        generation_metadata['cinematic_reduction'] = reduction
                    
                    # Finale Validierung vor Generierung
                    st.info(f"üéØ **Finale Validierung**: Verwende {prompt_name} Prompt mit {len(prompt_to_use)} Zeichen")
                    
                    # KRITISCH: Prompt-Vergleich
                    if hasattr(result, 'dalle_prompt'):
                        dalle_length = len(result.dalle_prompt)
                        cinematic_length = len(prompt_to_use) if prompt_name == "Cinematic" else 0
                        st.info(f"üìä **Prompt-Vergleich**: DALL-E={dalle_length} vs Cinematic={cinematic_length} Zeichen")
                        
                        if prompt_name == "Cinematic" and cinematic_length > 0:
                            if cinematic_length < dalle_length:
                                st.success(f"‚úÖ **Cinematic ist k√ºrzer**: {dalle_length - cinematic_length} Zeichen weniger")
                            else:
                                st.warning(f"‚ö†Ô∏è **Cinematic ist l√§nger**: {cinematic_length - dalle_length} Zeichen mehr")
                    
                    # Creative generieren mit Enhanced Generator
                    generation_result = enhanced_generator.generate_creative_from_prompt(
                        prompt_to_use, 
                        generation_metadata
                    )
                    
                    if generation_result['success']:
                        st.session_state['generated_creative'] = generation_result
                        st.success("üéâ Enhanced Creative erfolgreich generiert!")
                        st.rerun()
                    else:
                        st.error(f"‚ùå Generierung fehlgeschlagen: {generation_result['error']}")
                        
                except Exception as e:
                    st.error(f"‚ùå Fehler bei der Creative-Generierung: {str(e)}")
    
    with col3:
        # Download-Button f√ºr den Prompt
        dalle_prompt_download = result.dalle_prompt.encode('utf-8')
        st.download_button(
            "üì• Prompt downloaden",
            data=dalle_prompt_download,
            file_name=f"dalle_prompt_{unternehmen}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain",
            use_container_width=True
        )
    
    # Generiertes Creative anzeigen (falls vorhanden)
    if 'generated_creative' in st.session_state and st.session_state['generated_creative']['success']:
        creative_result = st.session_state['generated_creative']
        
        st.divider()
        st.subheader("üñºÔ∏è Generiertes Creative Ad")
        
        # Upload-Referenz Hinweis (Anhang-Modus) - PLATZHALTER-MODUS
        metadata = creative_result.get('metadata', {})
        if metadata.get('motiv_source') == "üñºÔ∏è Eigenes Bild hochladen":
            st.info(f"""
            üìé **Anhang-Modus aktiv**: Der Prompt enth√§lt einen generischen Verweis auf "angeh√§ngtes Bild"
            
            üí° **Verwendung**: 
            1. Kopiere den generierten Prompt 
            2. H√§nge dein Bild an die Nachricht in ChatGPT/Midjourney an
            3. Der Prompt weist auf das Anhang-Bild hin - kein Upload im Tool n√∂tig!
            """)
        
        
        # Bild anzeigen
        col1, col2 = st.columns([3, 1])
        
        with col1:
            try:
                image_path = Path(creative_result['image_path'])
                if image_path.exists():
                    st.image(
                        str(image_path), 
                        caption=f"Creative Ad - {creative_result['timestamp']}", 
                        use_column_width=True
                    )
                else:
                    st.error("‚ùå Generiertes Bild nicht gefunden")
            except Exception as e:
                st.error(f"‚ùå Fehler beim Anzeigen des Bildes: {e}")
        
        with col2:
            st.metric("‚è±Ô∏è Generierungszeit", f"{creative_result['generation_time']:.1f}s")
            st.metric("üìê Aufl√∂sung", "1792x1024 px")
            
            # Quality Badge f√ºr Enhanced Creative Generator
            if creative_result.get('method') == 'enhanced_creative_generator':
                st.metric("üéØ Qualit√§t", "HD (Enhanced Generator)")
                st.success("üé® Creative Core Prinzipien!")
            elif creative_result.get('chatgpt_enhanced', False):  # Legacy support
                st.metric("üéØ Qualit√§t", "HD + PROFI Enhanced")
                st.success("üèÜ Commercial Photography Level!")
            elif 'enhanced_prompt' in creative_result:  # Legacy support
                st.metric("üéØ Qualit√§t", "HD + Enhanced")
                st.success("üß† Mit ChatGPT optimiert!")
            else:
                st.metric("üéØ Qualit√§t", "HD (DALL-E 3)")
                st.info("‚ö° Standard-Modus")
            
            # Download-Button f√ºr das Bild
            try:
                image_path = Path(creative_result['image_path'])
                if image_path.exists():
                    with open(image_path, "rb") as file:
                        st.download_button(
                            "üì• Bild downloaden",
                            data=file.read(),
                            file_name=image_path.name,
                            mime="image/png",
                            use_container_width=True
                        )
            except Exception as e:
                st.error(f"‚ùå Download-Fehler: {e}")
        
        # Generierungs-Details f√ºr Enhanced Creative Generator
        with st.expander("üìã Generierungs-Details"):
            details_data = {
                'Generierungszeit': f"{creative_result['generation_time']:.2f} Sekunden",
                'Generator-Methode': creative_result.get('method', 'unknown'),
                'DALL-E Einstellungen': creative_result.get('dalle_settings', {}),
                'Datei-Pfad': creative_result['image_path'],
                'Timestamp': creative_result.get('timestamp', 'unknown')
            }
            
            # Zus√§tzliche Metadaten falls verf√ºgbar
            if 'metadata' in creative_result:
                details_data['Zus√§tzliche Metadaten'] = creative_result['metadata']
            
            st.json(details_data)
            
            # Prompt-Anzeige f√ºr Enhanced Creative Generator
            st.markdown("**Verwendeter Prompt:**")
            prompt_to_show = creative_result.get('prompt_used', 'Nicht verf√ºgbar')
            st.text_area(
                "Enhanced Generator Prompt:",
                value=prompt_to_show,
                height=150,
                help="Prompt der an den Enhanced Creative Generator gesendet wurde",
                key="enhanced_generator_prompt_display"
            )
            st.caption(f"üìä L√§nge: {len(prompt_to_show)} Zeichen")
            
            # DALL-E's eigene √úberarbeitung anzeigen (falls verf√ºgbar)
            if creative_result.get('revised_prompt') and creative_result['revised_prompt'] != prompt_to_show:
                st.markdown("**DALL-E 3 finale √úberarbeitung:**")
                st.text_area(
                    "DALL-E Revised:",
                    value=creative_result['revised_prompt'],
                    height=100,
                    help="DALL-E 3's eigene finale Anpassung des Prompts",
                    key="enhanced_revised_prompt_display"
                )
                st.caption(f"üìä DALL-E Revised L√§nge: {len(creative_result['revised_prompt'])} Zeichen")
        
        # Button zum L√∂schen/Zur√ºcksetzen
        if st.button("üóëÔ∏è Creative zur√ºcksetzen", help="Entfernt das angezeigte Creative aus der Anzeige"):
            if 'generated_creative' in st.session_state:
                del st.session_state['generated_creative']
            st.rerun()
        


elif 'prompt_result' in st.session_state and not ENHANCED_CREATIVE_AVAILABLE:
    # Falls Prompt existiert aber Enhanced Creative Generator nicht verf√ºgbar ist
    st.divider()
    st.info("üí° Enhanced Creative Generator ist nicht verf√ºgbar. Bitte √ºberpr√ºfe deine OpenAI API-Einstellungen.")

# Prompt Display wurde entfernt - nur Enhanced Creative Generator bleibt



# Footer
st.divider()
st.markdown("""
<div style="text-align: center; color: #666; padding: 1rem;">
    <small>üöÄ CreativeAI - Promptgenerator | Intelligente Prompt-Generierung f√ºr DALL-E & Midjourney</small>
</div>
""", unsafe_allow_html=True) 